# E1.5: Web Foundation Implementation Plan

## Overview

Create the @hermit/web package with Next.js + Panda CSS. Implement authentication, machine/session listing, and a basic terminal viewer.

## Dependencies

| Package          | Version | Purpose               |
| ---------------- | ------- | --------------------- |
| next             | 16.1.5  | React framework       |
| react            | 19.2.3  | UI library            |
| react-dom        | 19.2.3  | React DOM renderer    |
| @pandacss/dev    | 1.8.1   | CSS-in-JS (dev)       |
| @xterm/xterm     | 6.0.0   | Terminal emulator     |
| @xterm/addon-fit | 0.10.0  | Terminal resize addon |
| zustand          | 5.0.10  | State management      |
| jwt-decode       | 4.0.0   | JWT token parsing     |
| zod              | 4.3.6   | Runtime validation    |

## Architecture

```
apps/web/
├── src/
│   ├── app/                    # Next.js App Router
│   │   ├── layout.tsx          # Root layout with providers
│   │   ├── page.tsx            # Home (redirect to /machines)
│   │   ├── login/
│   │   │   └── page.tsx        # Login page
│   │   └── machines/
│   │       ├── page.tsx        # Machine list
│   │       └── [machineId]/
│   │           ├── page.tsx    # Session list
│   │           └── [sessionId]/
│   │               └── page.tsx # Terminal view
│   ├── components/
│   │   ├── auth/
│   │   │   └── LoginForm.tsx
│   │   ├── machines/
│   │   │   ├── MachineCard.tsx
│   │   │   └── MachineList.tsx
│   │   ├── sessions/
│   │   │   ├── SessionCard.tsx
│   │   │   └── SessionList.tsx
│   │   └── terminal/
│   │       └── Terminal.tsx
│   ├── hooks/
│   │   ├── useAuth.ts
│   │   └── useWebSocket.ts
│   ├── stores/
│   │   ├── auth.ts             # Auth state (token, user)
│   │   └── relay.ts            # WebSocket connection state
│   ├── lib/
│   │   ├── api.ts              # REST API client
│   │   └── ws.ts               # WebSocket client
│   └── styled-system/          # Panda CSS generated
├── panda.config.ts
├── postcss.config.cjs
└── next.config.ts
```

## Stories

### 1.5.1: Create @hermit/web package with Next.js

**Tasks:**

1. Create package.json with dependencies
2. Configure Next.js 16.1.x with App Router
3. Set up Panda CSS with design tokens
4. Configure TypeScript, ESLint, Vitest
5. Create root layout with basic structure

**Package.json:**

```json
{
  "name": "@hermit/web",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "concurrently 'next dev -p 3000' 'panda --watch'",
    "build": "panda codegen && next build",
    "start": "next start -p 3000",
    "lint": "eslint . --max-warnings 0",
    "test": "vitest --run",
    "prepare": "panda codegen"
  }
}
```

**panda.config.ts:**

```typescript
import { defineConfig } from '@pandacss/dev';

export default defineConfig({
  preflight: true,
  include: ['./src/**/*.{js,jsx,ts,tsx}'],
  exclude: [],
  outdir: 'src/styled-system',
  theme: {
    extend: {
      tokens: {
        colors: {
          primary: { value: '#3b82f6' },
          surface: { value: '#1e1e2e' },
          text: { value: '#cdd6f4' },
          muted: { value: '#6c7086' },
          border: { value: '#313244' },
        },
      },
    },
  },
});
```

### 1.5.2: Implement login page

**Tasks:**

1. Create auth store with Zustand
2. Create REST API client for auth endpoints
3. Create LoginForm component
4. Create login page with form handling
5. Implement token storage (localStorage)
6. Add auth redirect middleware

**Auth Store (stores/auth.ts):**

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

type AuthState = {
  token: string | null;
  user: { id: string; email: string } | null;
  setAuth: (token: string, user: { id: string; email: string }) => void;
  logout: () => void;
  isAuthenticated: () => boolean;
};

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      token: null,
      user: null,
      setAuth: (token, user) => set({ token, user }),
      logout: () => set({ token: null, user: null }),
      isAuthenticated: () => get().token !== null,
    }),
    { name: 'hermit-auth' },
  ),
);
```

**API Client (lib/api.ts):**

```typescript
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

export const api = {
  async login(email: string, password: string) {
    const res = await fetch(`${API_URL}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });
    if (!res.ok) throw new Error('Login failed');
    return res.json();
  },

  async getMachines(token: string) {
    const res = await fetch(`${API_URL}/api/machines`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    if (!res.ok) throw new Error('Failed to fetch machines');
    return res.json();
  },
};
```

### 1.5.3: Implement WebSocket context provider

**Tasks:**

1. Create WebSocket client wrapper
2. Create relay store for connection state
3. Create WebSocket hook with auto-reconnect
4. Create context provider for app-wide access

**WebSocket Client (lib/ws.ts):**

```typescript
import type { ClientToRelayMessage, RelayToClientMessage } from '@hermit/protocol';

export type WebSocketClient = {
  connect: () => void;
  disconnect: () => void;
  send: (message: ClientToRelayMessage) => void;
  onMessage: (handler: (message: RelayToClientMessage) => void) => () => void;
  isConnected: () => boolean;
};

export const createWebSocketClient = (url: string, token: string): WebSocketClient => {
  let ws: WebSocket | null = null;
  let connected = false;
  const handlers = new Set<(message: RelayToClientMessage) => void>();

  const connect = () => {
    ws = new WebSocket(url);

    ws.onopen = () => {
      connected = true;
      ws?.send(JSON.stringify({ type: 'authenticate', token }));
    };

    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      handlers.forEach((h) => h(message));
    };

    ws.onclose = () => {
      connected = false;
      // Auto-reconnect after 2s
      setTimeout(connect, 2000);
    };
  };

  return {
    connect,
    disconnect: () => ws?.close(),
    send: (msg) => ws?.send(JSON.stringify(msg)),
    onMessage: (handler) => {
      handlers.add(handler);
      return () => handlers.delete(handler);
    },
    isConnected: () => connected,
  };
};
```

**Relay Store (stores/relay.ts):**

```typescript
import { create } from 'zustand';
import type { MachineInfo, SessionInfo } from '@hermit/protocol';

type RelayState = {
  connected: boolean;
  machines: MachineInfo[];
  sessions: Map<string, SessionInfo[]>;
  setConnected: (connected: boolean) => void;
  setMachines: (machines: MachineInfo[]) => void;
  setSessions: (machineId: string, sessions: SessionInfo[]) => void;
};

export const useRelayStore = create<RelayState>((set) => ({
  connected: false,
  machines: [],
  sessions: new Map(),
  setConnected: (connected) => set({ connected }),
  setMachines: (machines) => set({ machines }),
  setSessions: (machineId, sessions) =>
    set((state) => ({
      sessions: new Map(state.sessions).set(machineId, sessions),
    })),
}));
```

### 1.5.4: Implement machine list page

**Tasks:**

1. Create MachineCard component
2. Create MachineList component
3. Create machines page with data fetching
4. Show online/offline status
5. Link to session list

**MachineCard Component:**

```typescript
import { css } from '@/styled-system/css';
import type { MachineInfo } from '@hermit/protocol';
import Link from 'next/link';

type Props = { machine: MachineInfo };

export const MachineCard = ({ machine }: Props) => (
  <Link
    href={`/machines/${machine.id}`}
    className={css({
      display: 'block',
      p: '4',
      bg: 'surface',
      border: '1px solid',
      borderColor: 'border',
      borderRadius: 'md',
      _hover: { borderColor: 'primary' },
    })}
  >
    <div className={css({ display: 'flex', alignItems: 'center', gap: '2' })}>
      <span
        className={css({
          w: '2',
          h: '2',
          borderRadius: 'full',
          bg: machine.online ? 'green.500' : 'red.500',
        })}
      />
      <span className={css({ fontWeight: 'bold', color: 'text' })}>
        {machine.name}
      </span>
    </div>
    <p className={css({ mt: '2', color: 'muted', fontSize: 'sm' })}>
      {machine.sessionCount} sessions
    </p>
  </Link>
);
```

### 1.5.5: Implement session list for selected machine

**Tasks:**

1. Create SessionCard component
2. Create SessionList component
3. Create machine detail page
4. Fetch sessions via WebSocket
5. Link to terminal view

**Session List Page ([machineId]/page.tsx):**

```typescript
'use client';

import { useEffect } from 'react';
import { useParams } from 'next/navigation';
import { css } from '@/styled-system/css';
import { useRelayStore } from '@/stores/relay';
import { useWebSocket } from '@/hooks/useWebSocket';
import { SessionList } from '@/components/sessions/SessionList';

export default function MachineSessionsPage() {
  const { machineId } = useParams<{ machineId: string }>();
  const { send } = useWebSocket();
  const sessions = useRelayStore((s) => s.sessions.get(machineId) || []);

  useEffect(() => {
    send({ type: 'list_sessions', machineId });
  }, [machineId, send]);

  return (
    <div className={css({ p: '6' })}>
      <h1 className={css({ fontSize: '2xl', fontWeight: 'bold', mb: '4' })}>
        Sessions
      </h1>
      <SessionList sessions={sessions} machineId={machineId} />
    </div>
  );
}
```

### 1.5.6: Implement basic terminal view (read-only)

**Tasks:**

1. Create Terminal component with xterm.js
2. Create terminal page
3. Attach to session via WebSocket
4. Display terminal output (read-only for M1)
5. Handle resize events

**Terminal Component:**

```typescript
'use client';

import { useEffect, useRef } from 'react';
import { Terminal as XTerm } from '@xterm/xterm';
import { FitAddon } from '@xterm/addon-fit';
import '@xterm/xterm/css/xterm.css';
import { css } from '@/styled-system/css';

type Props = {
  onData?: (data: string) => void;
  onResize?: (cols: number, rows: number) => void;
};

export const Terminal = ({ onData, onResize }: Props) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const termRef = useRef<XTerm | null>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    const term = new XTerm({
      theme: {
        background: '#1e1e2e',
        foreground: '#cdd6f4',
        cursor: '#f5e0dc',
      },
      fontFamily: 'JetBrains Mono, monospace',
      fontSize: 14,
    });

    const fitAddon = new FitAddon();
    term.loadAddon(fitAddon);
    term.open(containerRef.current);
    fitAddon.fit();

    termRef.current = term;

    if (onData) {
      term.onData(onData);
    }

    const resizeObserver = new ResizeObserver(() => {
      fitAddon.fit();
      onResize?.(term.cols, term.rows);
    });
    resizeObserver.observe(containerRef.current);

    return () => {
      resizeObserver.disconnect();
      term.dispose();
    };
  }, [onData, onResize]);

  // Expose write method for incoming data
  const write = (data: string) => {
    termRef.current?.write(data);
  };

  return (
    <div
      ref={containerRef}
      className={css({
        w: 'full',
        h: 'full',
        minH: '400px',
        bg: 'surface',
        borderRadius: 'md',
        overflow: 'hidden',
      })}
    />
  );
};
```

**Terminal Page:**

```typescript
'use client';

import { useEffect, useRef, useCallback } from 'react';
import { useParams } from 'next/navigation';
import { css } from '@/styled-system/css';
import { useWebSocket } from '@/hooks/useWebSocket';
import { Terminal } from '@/components/terminal/Terminal';

export default function TerminalPage() {
  const { machineId, sessionId } = useParams<{ machineId: string; sessionId: string }>();
  const { send, onMessage } = useWebSocket();
  const terminalRef = useRef<{ write: (data: string) => void } | null>(null);

  useEffect(() => {
    // Attach to session
    send({ type: 'attach', machineId, sessionId });

    // Listen for terminal data
    const unsubscribe = onMessage((msg) => {
      if (msg.type === 'data' && msg.sessionId === sessionId) {
        const decoded = atob(msg.data);
        terminalRef.current?.write(decoded);
      }
    });

    return () => {
      unsubscribe();
      send({ type: 'detach', machineId, sessionId });
    };
  }, [machineId, sessionId, send, onMessage]);

  const handleResize = useCallback(
    (cols: number, rows: number) => {
      send({ type: 'resize', machineId, sessionId, cols, rows });
    },
    [machineId, sessionId, send]
  );

  return (
    <div className={css({ h: '100vh', p: '4', bg: 'black' })}>
      <Terminal
        ref={terminalRef}
        onResize={handleResize}
        // onData omitted for M1 (read-only)
      />
    </div>
  );
}
```

## Testing Strategy

| Component       | Test Focus                             |
| --------------- | -------------------------------------- |
| stores/auth.ts  | Token persistence, login/logout        |
| stores/relay.ts | State updates, session mapping         |
| lib/api.ts      | API calls, error handling              |
| lib/ws.ts       | Connection lifecycle, message handling |
| components/\*   | Render tests with mock data            |

## Implementation Order

1. **1.5.1** - Package setup (skeleton, configs, Panda CSS)
2. **1.5.2** - Login (auth store, API client, login page)
3. **1.5.3** - WebSocket (ws client, relay store, hook)
4. **1.5.4** - Machine list (components, page)
5. **1.5.5** - Session list (components, page)
6. **1.5.6** - Terminal view (xterm integration)

## Notes

- M1 terminal is **read-only** - input will be added in M2
- WebSocket reconnection is simple (fixed 2s delay) - exponential backoff in M3
- No OAuth yet - simple email/password login for M1
- Design uses dark theme to match terminal aesthetic
