# E1.4 Agent Foundation - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create the @hermit/agent package - a Bun CLI that manages tmux sessions and connects to the relay server via WebSocket.

**Architecture:** CLI application using commander.js for argument parsing, running on Bun runtime for single-binary compilation. Manages tmux sessions locally and maintains a persistent WebSocket connection to the relay.

**Tech Stack:**

- Bun 1.2.x runtime (for single binary compilation)
- commander 14.0.2 (CLI framework)
- ws 8.19.0 (WebSocket client - works with Bun)
- Vitest 4.0.18 (testing - same as other packages)
- @hermit/protocol (shared types)

**Security Note:** All shell commands use `execFileSync` with explicit argument arrays to prevent command injection. User-provided values are passed as arguments, not interpolated into command strings.

**Reference repos:**

- Monorepo patterns: `/Volumes/External Storage/Workspace/gifcept`
- Shared configs: `/Volumes/External Storage/Workspace/slango`

---

## Task 20: Create @hermit/agent Package Skeleton (E1.4/1.4.1)

**Files:**

- Create: `apps/agent/package.json`
- Create: `apps/agent/tsconfig.json`
- Create: `apps/agent/tsconfig.build.json`
- Create: `apps/agent/eslint.config.js`
- Create: `apps/agent/vitest.config.js`
- Create: `apps/agent/src/index.ts`
- Create: `apps/agent/src/cli.ts`

**Step 1: Create apps/agent/package.json**

```json
{
  "name": "@hermit/agent",
  "version": "0.0.1",
  "private": true,
  "description": "Hermit agent - manages tmux sessions and connects to relay",
  "type": "module",
  "bin": {
    "hermit": "./dist/cli.js"
  },
  "scripts": {
    "dev": "bun run src/cli.ts",
    "build": "tsc -p tsconfig.build.json",
    "build:watch": "tsc --watch -p tsconfig.build.json",
    "build:check": "tsc --noEmit",
    "compile": "bun build src/cli.ts --compile --outfile dist/hermit",
    "lint": "eslint . --max-warnings 0",
    "lint:fix": "eslint . --fix --max-warnings 0",
    "test": "vitest --run",
    "test:watch": "vitest",
    "check": "pnpm build:check && pnpm lint && pnpm test"
  },
  "dependencies": {
    "@hermit/protocol": "workspace:*",
    "commander": "14.0.2",
    "ws": "8.19.0"
  },
  "devDependencies": {
    "@slango.configs/eslint": "1.1.47",
    "@slango.configs/typescript": "1.0.7",
    "@slango.configs/vitest": "2.0.4",
    "@types/node": "24.0.10",
    "@types/ws": "8.18.1",
    "@vitest/coverage-v8": "4.0.18",
    "eslint": "9.39.2",
    "typescript": "5.9.3",
    "vitest": "4.0.18"
  }
}
```

**Step 2: Create apps/agent/tsconfig.json**

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@slango.configs/typescript/default.json",
  "compilerOptions": {
    "noEmit": true
  },
  "include": ["**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
```

**Step 3: Create apps/agent/tsconfig.build.json**

```json
{
  "$schema": "https://json-schema.store.org/tsconfig",
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "exclude": ["node_modules", "dist", "src/**/*.test.ts"]
}
```

**Step 4: Create apps/agent/eslint.config.js**

```javascript
export { default } from '@slango.configs/eslint/typescript.js';
```

**Step 5: Create apps/agent/vitest.config.js**

```javascript
export { default } from '@slango.configs/vitest/default';
```

**Step 6: Create apps/agent/src/index.ts**

```typescript
export const VERSION = '0.0.1';
```

**Step 7: Create apps/agent/src/cli.ts**

```typescript
#!/usr/bin/env node
import { Command } from 'commander';

import { VERSION } from './index.js';

const program = new Command();

program.name('hermit').description('Hermit agent - terminal relay client').version(VERSION);

program
  .command('init')
  .description('Initialize hermit configuration')
  .action(() => {
    console.log('hermit init - not yet implemented');
  });

program
  .command('connect')
  .description('Connect to the relay server')
  .option('-d, --daemon', 'Run in background')
  .action(() => {
    console.log('hermit connect - not yet implemented');
  });

program
  .command('list')
  .description('List tmux sessions')
  .action(() => {
    console.log('hermit list - not yet implemented');
  });

program
  .command('new <name>')
  .description('Create a new tmux session')
  .action((name: string) => {
    console.log(`hermit new ${name} - not yet implemented`);
  });

program.parse();
```

**Step 8: Install dependencies and build**

Run:

```bash
pnpm install
pnpm --filter @hermit/agent build
```

Expected: Build succeeds, dist/ created

**Step 9: Test the CLI works**

Run:

```bash
pnpm --filter @hermit/agent dev -- --help
```

Expected: Shows help with init, connect, list, new commands

**Step 10: Commit**

```bash
git add apps/agent
git commit -m "M1/E1.4/1.4.1: Create @hermit/agent package skeleton"
```

---

## Task 21: Implement Config Manager (E1.4/1.4.2)

**Files:**

- Create: `apps/agent/src/config.ts`
- Create: `apps/agent/src/config.test.ts`

**Step 1: Create apps/agent/src/config.ts**

```typescript
import { existsSync, mkdirSync, readFileSync, unlinkSync, writeFileSync } from 'node:fs';
import { homedir } from 'node:os';
import { dirname, join } from 'node:path';

export type HermitConfig = {
  machineId: string;
  machineName: string;
  relayUrl: string;
  token: string;
};

const CONFIG_DIR = join(homedir(), '.hermit');
const CONFIG_FILE = join(CONFIG_DIR, 'config.json');

export const getConfigPath = (): string => CONFIG_FILE;

export const getConfigDir = (): string => CONFIG_DIR;

export const configExists = (): boolean => {
  return existsSync(CONFIG_FILE);
};

export const loadConfig = (): HermitConfig | null => {
  if (!configExists()) {
    return null;
  }

  try {
    const content = readFileSync(CONFIG_FILE, 'utf-8');
    const config = JSON.parse(content) as HermitConfig;

    // Validate required fields
    if (!config.machineId || !config.machineName || !config.relayUrl || !config.token) {
      return null;
    }

    return config;
  } catch {
    return null;
  }
};

export const saveConfig = (config: HermitConfig): void => {
  const dir = dirname(CONFIG_FILE);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2) + '\n');
};

export const deleteConfig = (): void => {
  if (existsSync(CONFIG_FILE)) {
    unlinkSync(CONFIG_FILE);
  }
};
```

**Step 2: Create apps/agent/src/config.test.ts**

```typescript
import { existsSync, mkdirSync, rmSync, writeFileSync } from 'node:fs';
import { tmpdir } from 'node:os';
import { join } from 'node:path';
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

// We need to mock the config paths before importing
const TEST_CONFIG_DIR = join(tmpdir(), 'hermit-test-' + Date.now());
const TEST_CONFIG_FILE = join(TEST_CONFIG_DIR, 'config.json');

vi.mock('node:os', async () => {
  const actual = await vi.importActual('node:os');
  return {
    ...actual,
    homedir: () => TEST_CONFIG_DIR.replace('/.hermit', ''),
  };
});

// Import after mocking
import { configExists, deleteConfig, loadConfig, saveConfig, type HermitConfig } from './config.js';

describe('Config manager', () => {
  beforeEach(() => {
    // Clean up test directory
    if (existsSync(TEST_CONFIG_DIR)) {
      rmSync(TEST_CONFIG_DIR, { recursive: true });
    }
  });

  afterEach(() => {
    // Clean up test directory
    if (existsSync(TEST_CONFIG_DIR)) {
      rmSync(TEST_CONFIG_DIR, { recursive: true });
    }
  });

  describe('configExists', () => {
    it('returns false when config does not exist', () => {
      expect(configExists()).toBe(false);
    });

    it('returns true when config exists', () => {
      mkdirSync(TEST_CONFIG_DIR, { recursive: true });
      writeFileSync(TEST_CONFIG_FILE, '{}');
      expect(configExists()).toBe(true);
    });
  });

  describe('saveConfig and loadConfig', () => {
    it('saves and loads config', () => {
      const config: HermitConfig = {
        machineId: 'machine-123',
        machineName: 'My Workstation',
        relayUrl: 'wss://relay.example.com/ws/agent',
        token: 'hmt_testtoken123',
      };

      saveConfig(config);
      const loaded = loadConfig();

      expect(loaded).toEqual(config);
    });

    it('creates config directory if it does not exist', () => {
      const config: HermitConfig = {
        machineId: 'machine-123',
        machineName: 'Test',
        relayUrl: 'wss://relay.example.com/ws/agent',
        token: 'hmt_test',
      };

      saveConfig(config);
      expect(existsSync(TEST_CONFIG_DIR)).toBe(true);
    });
  });

  describe('loadConfig', () => {
    it('returns null for missing config', () => {
      expect(loadConfig()).toBeNull();
    });

    it('returns null for invalid JSON', () => {
      mkdirSync(TEST_CONFIG_DIR, { recursive: true });
      writeFileSync(TEST_CONFIG_FILE, 'not json');
      expect(loadConfig()).toBeNull();
    });

    it('returns null for config missing required fields', () => {
      mkdirSync(TEST_CONFIG_DIR, { recursive: true });
      writeFileSync(TEST_CONFIG_FILE, JSON.stringify({ machineId: 'test' }));
      expect(loadConfig()).toBeNull();
    });
  });

  describe('deleteConfig', () => {
    it('deletes existing config', () => {
      const config: HermitConfig = {
        machineId: 'machine-123',
        machineName: 'Test',
        relayUrl: 'wss://relay.example.com/ws/agent',
        token: 'hmt_test',
      };

      saveConfig(config);
      expect(configExists()).toBe(true);

      deleteConfig();
      expect(configExists()).toBe(false);
    });

    it('does nothing if config does not exist', () => {
      expect(() => deleteConfig()).not.toThrow();
    });
  });
});
```

**Step 3: Run tests**

Run:

```bash
pnpm --filter @hermit/agent test src/config.test.ts
```

Expected: All tests pass

**Step 4: Commit**

```bash
git add apps/agent/src/config.ts apps/agent/src/config.test.ts
git commit -m "M1/E1.4/1.4.2: Implement config manager (~/.hermit/config.json)"
```

---

## Task 22: Implement Tmux Controller (E1.4/1.4.4)

**Files:**

- Create: `apps/agent/src/tmux.ts`
- Create: `apps/agent/src/tmux.test.ts`

**Step 1: Create apps/agent/src/tmux.ts**

Note: Uses `execFileSync` with argument arrays for security (no shell interpolation).

```typescript
import { execFileSync, spawn } from 'node:child_process';

import type { SessionInfo } from '@hermit/protocol/types.js';

export type TmuxSession = {
  id: string;
  name: string;
  createdAt: Date;
  attached: boolean;
};

const runTmux = (args: string[]): string => {
  try {
    return execFileSync('tmux', args, {
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
    }).trim();
  } catch (error) {
    const execError = error as { status?: number; stderr?: Buffer | string };
    const stderr = execError.stderr?.toString() || '';
    if (execError.status === 1 && stderr.includes('no server running')) {
      return '';
    }
    throw error;
  }
};

export const isTmuxAvailable = (): boolean => {
  try {
    execFileSync('which', ['tmux'], { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
};

export const listSessions = (): TmuxSession[] => {
  const output = runTmux([
    'list-sessions',
    '-F',
    '#{session_id}:#{session_name}:#{session_created}:#{session_attached}',
  ]);

  if (!output) {
    return [];
  }

  return output.split('\n').map((line) => {
    const [id, name, createdTimestamp, attached] = line.split(':');
    return {
      id: id.replace('$', ''),
      name,
      createdAt: new Date(Number(createdTimestamp) * 1000),
      attached: attached === '1',
    };
  });
};

export const sessionExists = (name: string): boolean => {
  try {
    runTmux(['has-session', '-t', name]);
    return true;
  } catch {
    return false;
  }
};

export const createSession = (name: string, command?: string): TmuxSession => {
  const args = ['new-session', '-d', '-s', name, '-P', '-F', '#{session_id}:#{session_created}'];
  if (command) {
    args.push(command);
  }

  const output = runTmux(args);
  const [id, createdTimestamp] = output.split(':');

  return {
    id: id.replace('$', ''),
    name,
    createdAt: new Date(Number(createdTimestamp) * 1000),
    attached: false,
  };
};

export const killSession = (name: string): void => {
  runTmux(['kill-session', '-t', name]);
};

export const toSessionInfo = (session: TmuxSession): SessionInfo => {
  return {
    id: session.id,
    name: session.name,
    command: 'tmux', // tmux doesn't easily expose the command
    createdAt: session.createdAt.toISOString(),
    attachedClients: session.attached ? 1 : 0,
  };
};

export const sendKeys = (sessionId: string, data: string): void => {
  // Use spawn to handle binary data properly
  const tmux = spawn('tmux', ['send-keys', '-t', `$${sessionId}`, '-l', data]);
  tmux.stdin.end();
};

export const capturePane = (sessionId: string): string => {
  return runTmux(['capture-pane', '-t', `$${sessionId}`, '-p']);
};

export type PtyProcess = {
  onData: (callback: (data: string) => void) => void;
  write: (data: string) => void;
  resize: (cols: number, rows: number) => void;
  kill: () => void;
};

export const attachToSession = (sessionId: string): PtyProcess => {
  const tmux = spawn('tmux', ['attach-session', '-t', `$${sessionId}`], {
    stdio: ['pipe', 'pipe', 'pipe'],
  });

  const callbacks: ((data: string) => void)[] = [];

  tmux.stdout.on('data', (data: Buffer) => {
    const str = data.toString();
    callbacks.forEach((cb) => cb(str));
  });

  tmux.stderr.on('data', (data: Buffer) => {
    const str = data.toString();
    callbacks.forEach((cb) => cb(str));
  });

  return {
    onData: (callback) => {
      callbacks.push(callback);
    },
    write: (data) => {
      tmux.stdin.write(data);
    },
    resize: (cols, rows) => {
      runTmux(['resize-window', '-t', `$${sessionId}`, '-x', String(cols), '-y', String(rows)]);
    },
    kill: () => {
      tmux.kill();
    },
  };
};
```

**Step 2: Create apps/agent/src/tmux.test.ts**

```typescript
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

// Mock child_process
vi.mock('node:child_process', () => ({
  execFileSync: vi.fn(),
  spawn: vi.fn(() => ({
    stdin: { write: vi.fn(), end: vi.fn() },
    stdout: { on: vi.fn() },
    stderr: { on: vi.fn() },
    kill: vi.fn(),
  })),
}));

import { execFileSync } from 'node:child_process';

import {
  createSession,
  isTmuxAvailable,
  killSession,
  listSessions,
  sessionExists,
  toSessionInfo,
} from './tmux.js';

const mockExecFileSync = vi.mocked(execFileSync);

describe('Tmux controller', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('isTmuxAvailable', () => {
    it('returns true when tmux is available', () => {
      mockExecFileSync.mockReturnValueOnce(Buffer.from('/usr/bin/tmux'));
      expect(isTmuxAvailable()).toBe(true);
    });

    it('returns false when tmux is not available', () => {
      mockExecFileSync.mockImplementationOnce(() => {
        throw new Error('not found');
      });
      expect(isTmuxAvailable()).toBe(false);
    });
  });

  describe('listSessions', () => {
    it('returns empty array when no sessions', () => {
      const error = new Error('no server running') as Error & { status: number; stderr: Buffer };
      error.status = 1;
      error.stderr = Buffer.from('no server running on /tmp/tmux-501/default');
      mockExecFileSync.mockImplementationOnce(() => {
        throw error;
      });

      expect(listSessions()).toEqual([]);
    });

    it('parses tmux output correctly', () => {
      const now = Math.floor(Date.now() / 1000);
      mockExecFileSync.mockReturnValueOnce(
        `$0:main:${now}:0\n$1:dev:${now}:1` as unknown as Buffer,
      );

      const sessions = listSessions();
      expect(sessions).toHaveLength(2);
      expect(sessions[0].name).toBe('main');
      expect(sessions[0].attached).toBe(false);
      expect(sessions[1].name).toBe('dev');
      expect(sessions[1].attached).toBe(true);
    });
  });

  describe('sessionExists', () => {
    it('returns true when session exists', () => {
      mockExecFileSync.mockReturnValueOnce('' as unknown as Buffer);
      expect(sessionExists('main')).toBe(true);
    });

    it('returns false when session does not exist', () => {
      mockExecFileSync.mockImplementationOnce(() => {
        throw new Error("can't find session: main");
      });
      expect(sessionExists('main')).toBe(false);
    });
  });

  describe('createSession', () => {
    it('creates a session and returns info', () => {
      const now = Math.floor(Date.now() / 1000);
      mockExecFileSync.mockReturnValueOnce(`$5:${now}` as unknown as Buffer);

      const session = createSession('test-session');
      expect(session.id).toBe('5');
      expect(session.name).toBe('test-session');
      expect(session.attached).toBe(false);
    });
  });

  describe('killSession', () => {
    it('calls tmux kill-session', () => {
      mockExecFileSync.mockReturnValueOnce('' as unknown as Buffer);
      killSession('test-session');
      expect(mockExecFileSync).toHaveBeenCalledWith(
        'tmux',
        ['kill-session', '-t', 'test-session'],
        expect.any(Object),
      );
    });
  });

  describe('toSessionInfo', () => {
    it('converts TmuxSession to SessionInfo', () => {
      const tmuxSession = {
        id: '5',
        name: 'main',
        createdAt: new Date('2025-01-24T12:00:00Z'),
        attached: true,
      };

      const info = toSessionInfo(tmuxSession);
      expect(info.id).toBe('5');
      expect(info.name).toBe('main');
      expect(info.createdAt).toBe('2025-01-24T12:00:00.000Z');
      expect(info.attachedClients).toBe(1);
    });
  });
});
```

**Step 3: Run tests**

Run:

```bash
pnpm --filter @hermit/agent test src/tmux.test.ts
```

Expected: All tests pass

**Step 4: Commit**

```bash
git add apps/agent/src/tmux.ts apps/agent/src/tmux.test.ts
git commit -m "M1/E1.4/1.4.4: Implement tmux controller (list/create sessions)"
```

---

## Task 23: Implement `hermit init` Command (E1.4/1.4.3)

**Files:**

- Create: `apps/agent/src/commands/init.ts`
- Create: `apps/agent/src/commands/index.ts`
- Modify: `apps/agent/src/cli.ts`

**Step 1: Create apps/agent/src/commands/init.ts**

```typescript
import { hostname } from 'node:os';
import * as readline from 'node:readline';

import {
  configExists,
  getConfigPath,
  loadConfig,
  saveConfig,
  type HermitConfig,
} from '../config.js';
import { isTmuxAvailable } from '../tmux.js';

const prompt = (rl: readline.Interface, question: string): Promise<string> => {
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer.trim());
    });
  });
};

type InitOptions = {
  relayUrl?: string;
  machineName?: string;
  token?: string;
  force?: boolean;
};

export const initCommand = async (options: InitOptions): Promise<void> => {
  // Check if tmux is available
  if (!isTmuxAvailable()) {
    console.error('Error: tmux is not installed or not in PATH');
    console.error('Please install tmux: brew install tmux (macOS) or apt install tmux (Linux)');
    process.exit(1);
  }

  // Check if already configured
  if (configExists() && !options.force) {
    const existingConfig = loadConfig();
    if (existingConfig) {
      console.log('Hermit is already configured for this machine.');
      console.log(`  Machine: ${existingConfig.machineName}`);
      console.log(`  Relay: ${existingConfig.relayUrl}`);
      console.log(`  Config: ${getConfigPath()}`);
      console.log('\nUse --force to reconfigure.');
      return;
    }
  }

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  try {
    // Get relay URL
    let relayUrl = options.relayUrl;
    if (!relayUrl) {
      relayUrl = await prompt(rl, 'Relay URL (e.g., wss://hermit.example.com/ws/agent): ');
    }
    if (!relayUrl) {
      console.error('Error: Relay URL is required');
      process.exit(1);
    }

    // Validate relay URL
    try {
      const url = new URL(relayUrl);
      if (!['ws:', 'wss:'].includes(url.protocol)) {
        console.error('Error: Relay URL must start with ws:// or wss://');
        process.exit(1);
      }
    } catch {
      console.error('Error: Invalid relay URL');
      process.exit(1);
    }

    // Get machine name
    let machineName = options.machineName;
    if (!machineName) {
      const defaultName = hostname().split('.')[0];
      machineName = await prompt(rl, `Machine name [${defaultName}]: `);
      if (!machineName) {
        machineName = defaultName;
      }
    }

    // Get token
    let token = options.token;
    if (!token) {
      token = await prompt(rl, 'Machine token (from relay registration): ');
    }
    if (!token) {
      console.error('Error: Machine token is required');
      console.error('Register a machine via the relay web interface or API to get a token.');
      process.exit(1);
    }

    // Validate token format
    if (!token.startsWith('hmt_')) {
      console.error('Error: Invalid token format (should start with hmt_)');
      process.exit(1);
    }

    // Save config
    const config: HermitConfig = {
      machineId: '', // Will be set after successful registration
      machineName,
      relayUrl,
      token,
    };

    saveConfig(config);
    console.log('\nConfiguration saved to:', getConfigPath());
    console.log('\nNext steps:');
    console.log('  1. Run `hermit connect` to connect to the relay');
    console.log('  2. Use `hermit new <name>` to create a new session');
    console.log('  3. Use `hermit list` to see your sessions');
  } finally {
    rl.close();
  }
};
```

**Step 2: Create apps/agent/src/commands/index.ts**

```typescript
export { initCommand } from './init.js';
```

**Step 3: Update apps/agent/src/cli.ts**

```typescript
#!/usr/bin/env node
import { Command } from 'commander';

import { initCommand } from './commands/index.js';
import { VERSION } from './index.js';

const program = new Command();

program.name('hermit').description('Hermit agent - terminal relay client').version(VERSION);

program
  .command('init')
  .description('Initialize hermit configuration')
  .option('-r, --relay-url <url>', 'Relay WebSocket URL')
  .option('-n, --machine-name <name>', 'Name for this machine')
  .option('-t, --token <token>', 'Machine token from relay')
  .option('-f, --force', 'Overwrite existing configuration')
  .action(initCommand);

program
  .command('connect')
  .description('Connect to the relay server')
  .option('-d, --daemon', 'Run in background')
  .action(() => {
    console.log('hermit connect - not yet implemented');
  });

program
  .command('list')
  .description('List tmux sessions')
  .action(() => {
    console.log('hermit list - not yet implemented');
  });

program
  .command('new <name>')
  .description('Create a new tmux session')
  .action((name: string) => {
    console.log(`hermit new ${name} - not yet implemented`);
  });

program.parse();
```

**Step 4: Build and test manually**

Run:

```bash
pnpm --filter @hermit/agent build
pnpm --filter @hermit/agent dev -- init --help
```

Expected: Shows init command options

**Step 5: Commit**

```bash
git add apps/agent/src/commands apps/agent/src/cli.ts
git commit -m "M1/E1.4/1.4.3: Implement hermit init command"
```

---

## Task 24: Implement WebSocket Connection to Relay (E1.4/1.4.5)

**Files:**

- Create: `apps/agent/src/relay-connection.ts`
- Create: `apps/agent/src/relay-connection.test.ts`

**Step 1: Create apps/agent/src/relay-connection.ts**

```typescript
import type { RelayToAgentMessage } from '@hermit/protocol/agent-messages.js';
import type { SessionInfo } from '@hermit/protocol/types.js';
import WebSocket from 'ws';

import { safeParseRelayToAgentMessage } from '@hermit/protocol/schemas.js';

export type RelayConnectionConfig = {
  relayUrl: string;
  machineName: string;
  token: string;
  onRegistered: (machineId: string) => void;
  onListSessions: () => SessionInfo[];
  onStartSession: (name: string, command?: string) => SessionInfo | null;
  onAttach: (sessionId: string, clientId: string) => void;
  onDetach: (sessionId: string, clientId: string) => void;
  onData: (sessionId: string, data: string) => void;
  onResize: (sessionId: string, cols: number, rows: number) => void;
  onError: (error: Error) => void;
  onDisconnect: () => void;
};

export type RelayConnection = {
  connect: () => void;
  disconnect: () => void;
  isConnected: () => boolean;
  sendSessions: (sessions: SessionInfo[]) => void;
  sendSessionStarted: (session: SessionInfo) => void;
  sendSessionEnded: (sessionId: string) => void;
  sendData: (sessionId: string, data: string) => void;
};

const RECONNECT_DELAYS = [1000, 2000, 4000, 8000, 16000, 30000];

export const createRelayConnection = (config: RelayConnectionConfig): RelayConnection => {
  let ws: WebSocket | null = null;
  let connected = false;
  let reconnectAttempt = 0;
  let reconnectTimeout: NodeJS.Timeout | null = null;
  let pingInterval: NodeJS.Timeout | null = null;

  const send = (message: object): void => {
    if (ws && connected) {
      ws.send(JSON.stringify(message));
    }
  };

  const handleMessage = (data: WebSocket.RawData): void => {
    const str = data.toString();
    let parsed: unknown;

    try {
      parsed = JSON.parse(str);
    } catch {
      console.error('Invalid JSON from relay:', str);
      return;
    }

    const result = safeParseRelayToAgentMessage(parsed);
    if (!result.success) {
      console.error('Invalid message from relay:', parsed);
      return;
    }

    const message = result.data as RelayToAgentMessage;

    switch (message.type) {
      case 'registered':
        if (message.success && message.machineId) {
          config.onRegistered(message.machineId);
        } else {
          config.onError(new Error(message.error || 'Registration failed'));
        }
        break;

      case 'list_sessions':
        send({ type: 'sessions', sessions: config.onListSessions() });
        break;

      case 'start_session': {
        const session = config.onStartSession(message.name, message.command);
        if (session) {
          send({ type: 'session_started', session });
        }
        break;
      }

      case 'attach':
        config.onAttach(message.sessionId, message.clientId);
        break;

      case 'detach':
        config.onDetach(message.sessionId, message.clientId);
        break;

      case 'data':
        config.onData(message.sessionId, message.data);
        break;

      case 'resize':
        config.onResize(message.sessionId, message.cols, message.rows);
        break;

      case 'ping':
        send({ type: 'pong' });
        break;
    }
  };

  const connect = (): void => {
    if (ws) {
      ws.close();
    }

    console.log(`Connecting to relay: ${config.relayUrl}`);
    ws = new WebSocket(config.relayUrl);

    ws.on('open', () => {
      console.log('Connected to relay');
      connected = true;
      reconnectAttempt = 0;

      // Authenticate
      send({
        type: 'register',
        machineName: config.machineName,
        token: config.token,
      });

      // Start ping interval
      pingInterval = setInterval(() => {
        send({ type: 'pong' });
      }, 30000);
    });

    ws.on('message', handleMessage);

    ws.on('close', () => {
      console.log('Disconnected from relay');
      connected = false;
      config.onDisconnect();

      if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
      }

      // Reconnect with exponential backoff
      const delay = RECONNECT_DELAYS[Math.min(reconnectAttempt, RECONNECT_DELAYS.length - 1)];
      console.log(`Reconnecting in ${delay / 1000}s...`);
      reconnectAttempt++;

      reconnectTimeout = setTimeout(connect, delay);
    });

    ws.on('error', (error) => {
      console.error('WebSocket error:', error.message);
      config.onError(error);
    });
  };

  const disconnect = (): void => {
    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }

    if (pingInterval) {
      clearInterval(pingInterval);
      pingInterval = null;
    }

    if (ws) {
      ws.close();
      ws = null;
    }

    connected = false;
  };

  return {
    connect,
    disconnect,
    isConnected: () => connected,
    sendSessions: (sessions) => send({ type: 'sessions', sessions }),
    sendSessionStarted: (session) => send({ type: 'session_started', session }),
    sendSessionEnded: (sessionId) => send({ type: 'session_ended', sessionId }),
    sendData: (sessionId, data) => send({ type: 'data', sessionId, data }),
  };
};
```

**Step 2: Create apps/agent/src/relay-connection.test.ts**

```typescript
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

// Mock ws module
vi.mock('ws', () => {
  const MockWebSocket = vi.fn(() => ({
    on: vi.fn(),
    send: vi.fn(),
    close: vi.fn(),
  }));
  return { default: MockWebSocket };
});

import WebSocket from 'ws';

import { createRelayConnection, type RelayConnectionConfig } from './relay-connection.js';

const MockWebSocket = vi.mocked(WebSocket);

describe('RelayConnection', () => {
  let mockConfig: RelayConnectionConfig;
  let mockWsInstance: {
    on: ReturnType<typeof vi.fn>;
    send: ReturnType<typeof vi.fn>;
    close: ReturnType<typeof vi.fn>;
  };

  beforeEach(() => {
    vi.clearAllMocks();
    vi.useFakeTimers();

    mockWsInstance = {
      on: vi.fn(),
      send: vi.fn(),
      close: vi.fn(),
    };

    MockWebSocket.mockReturnValue(mockWsInstance as unknown as WebSocket);

    mockConfig = {
      relayUrl: 'wss://relay.example.com/ws/agent',
      machineName: 'test-machine',
      token: 'hmt_testtoken',
      onRegistered: vi.fn(),
      onListSessions: vi.fn().mockReturnValue([]),
      onStartSession: vi.fn(),
      onAttach: vi.fn(),
      onDetach: vi.fn(),
      onData: vi.fn(),
      onResize: vi.fn(),
      onError: vi.fn(),
      onDisconnect: vi.fn(),
    };
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  describe('connect', () => {
    it('creates WebSocket connection', () => {
      const connection = createRelayConnection(mockConfig);
      connection.connect();

      expect(MockWebSocket).toHaveBeenCalledWith('wss://relay.example.com/ws/agent');
    });

    it('sends register message on open', () => {
      const connection = createRelayConnection(mockConfig);
      connection.connect();

      // Find the 'open' handler and call it
      const openCall = mockWsInstance.on.mock.calls.find((call) => call[0] === 'open');
      expect(openCall).toBeDefined();
      const openHandler = openCall![1];
      openHandler();

      expect(mockWsInstance.send).toHaveBeenCalledWith(
        JSON.stringify({
          type: 'register',
          machineName: 'test-machine',
          token: 'hmt_testtoken',
        }),
      );
    });
  });

  describe('message handling', () => {
    it('handles registered message', () => {
      const connection = createRelayConnection(mockConfig);
      connection.connect();

      // Simulate open
      const openHandler = mockWsInstance.on.mock.calls.find((c) => c[0] === 'open')![1];
      openHandler();

      // Simulate message
      const messageHandler = mockWsInstance.on.mock.calls.find((c) => c[0] === 'message')![1];
      messageHandler(
        JSON.stringify({ type: 'registered', success: true, machineId: 'machine-123' }),
      );

      expect(mockConfig.onRegistered).toHaveBeenCalledWith('machine-123');
    });

    it('handles list_sessions message', () => {
      const mockSessions = [
        { id: '1', name: 'main', command: 'tmux', createdAt: '', attachedClients: 0 },
      ];
      mockConfig.onListSessions = vi.fn().mockReturnValue(mockSessions);

      const connection = createRelayConnection(mockConfig);
      connection.connect();

      const openHandler = mockWsInstance.on.mock.calls.find((c) => c[0] === 'open')![1];
      openHandler();

      const messageHandler = mockWsInstance.on.mock.calls.find((c) => c[0] === 'message')![1];
      messageHandler(JSON.stringify({ type: 'list_sessions' }));

      expect(mockConfig.onListSessions).toHaveBeenCalled();
      expect(mockWsInstance.send).toHaveBeenCalledWith(
        JSON.stringify({ type: 'sessions', sessions: mockSessions }),
      );
    });
  });

  describe('disconnect', () => {
    it('closes WebSocket', () => {
      const connection = createRelayConnection(mockConfig);
      connection.connect();
      connection.disconnect();

      expect(mockWsInstance.close).toHaveBeenCalled();
    });
  });

  describe('reconnection', () => {
    it('reconnects with exponential backoff', () => {
      const connection = createRelayConnection(mockConfig);
      connection.connect();

      // Simulate disconnect
      const closeHandler = mockWsInstance.on.mock.calls.find((c) => c[0] === 'close')![1];
      closeHandler();

      expect(mockConfig.onDisconnect).toHaveBeenCalled();

      // Fast-forward to first reconnect (1s)
      vi.advanceTimersByTime(1000);
      expect(MockWebSocket).toHaveBeenCalledTimes(2);
    });
  });
});
```

**Step 3: Run tests**

Run:

```bash
pnpm --filter @hermit/agent test src/relay-connection.test.ts
```

Expected: All tests pass

**Step 4: Commit**

```bash
git add apps/agent/src/relay-connection.ts apps/agent/src/relay-connection.test.ts
git commit -m "M1/E1.4/1.4.5: Implement WebSocket connection to relay"
```

---

## Task 25: Implement `hermit connect` Command (E1.4/1.4.6)

**Files:**

- Create: `apps/agent/src/commands/connect.ts`
- Modify: `apps/agent/src/commands/index.ts`
- Modify: `apps/agent/src/cli.ts`

**Step 1: Create apps/agent/src/commands/connect.ts**

```typescript
import type { SessionInfo } from '@hermit/protocol/types.js';

import { loadConfig, saveConfig } from '../config.js';
import { createRelayConnection, type RelayConnection } from '../relay-connection.js';
import {
  attachToSession,
  createSession,
  listSessions,
  sendKeys,
  toSessionInfo,
  type PtyProcess,
} from '../tmux.js';

type ConnectOptions = {
  daemon?: boolean;
};

let relayConnection: RelayConnection | null = null;
const attachedSessions = new Map<string, PtyProcess>();

export const connectCommand = async (options: ConnectOptions): Promise<void> => {
  const config = loadConfig();
  if (!config) {
    console.error('Error: Hermit is not configured.');
    console.error('Run `hermit init` first to configure the agent.');
    process.exit(1);
  }

  if (options.daemon) {
    console.log('Daemon mode not yet implemented');
    console.log('Running in foreground...');
  }

  console.log(`Connecting to relay as "${config.machineName}"...`);

  relayConnection = createRelayConnection({
    relayUrl: config.relayUrl,
    machineName: config.machineName,
    token: config.token,

    onRegistered: (machineId) => {
      console.log(`Registered with machine ID: ${machineId}`);
      // Update config with machine ID
      if (!config.machineId) {
        config.machineId = machineId;
        saveConfig(config);
      }
    },

    onListSessions: (): SessionInfo[] => {
      return listSessions().map(toSessionInfo);
    },

    onStartSession: (name, command): SessionInfo | null => {
      try {
        const session = createSession(name, command);
        return toSessionInfo(session);
      } catch (error) {
        console.error('Failed to create session:', error);
        return null;
      }
    },

    onAttach: (sessionId, clientId) => {
      console.log(`Client ${clientId} attaching to session ${sessionId}`);

      // If not already attached, start streaming output
      if (!attachedSessions.has(sessionId)) {
        const pty = attachToSession(sessionId);
        attachedSessions.set(sessionId, pty);

        pty.onData((data) => {
          const base64 = Buffer.from(data).toString('base64');
          relayConnection?.sendData(sessionId, base64);
        });
      }
    },

    onDetach: (sessionId, clientId) => {
      console.log(`Client ${clientId} detaching from session ${sessionId}`);
      // Note: We keep the session attached for now, in case other clients are viewing
      // Could implement reference counting later
    },

    onData: (sessionId, data) => {
      // Decode base64 and send to tmux
      const decoded = Buffer.from(data, 'base64').toString();
      sendKeys(sessionId, decoded);
    },

    onResize: (sessionId, cols, rows) => {
      const pty = attachedSessions.get(sessionId);
      if (pty) {
        pty.resize(cols, rows);
      }
    },

    onError: (error) => {
      console.error('Connection error:', error.message);
    },

    onDisconnect: () => {
      // Clean up attached sessions
      for (const [, pty] of attachedSessions) {
        pty.kill();
      }
      attachedSessions.clear();
    },
  });

  relayConnection.connect();

  // Handle shutdown
  const shutdown = (): void => {
    console.log('\nShutting down...');
    relayConnection?.disconnect();
    process.exit(0);
  };

  process.on('SIGINT', shutdown);
  process.on('SIGTERM', shutdown);

  // Keep process alive
  console.log('Press Ctrl+C to disconnect');
};
```

**Step 2: Update apps/agent/src/commands/index.ts**

```typescript
export { connectCommand } from './connect.js';
export { initCommand } from './init.js';
```

**Step 3: Update apps/agent/src/cli.ts**

```typescript
#!/usr/bin/env node
import { Command } from 'commander';

import { connectCommand, initCommand } from './commands/index.js';
import { VERSION } from './index.js';

const program = new Command();

program.name('hermit').description('Hermit agent - terminal relay client').version(VERSION);

program
  .command('init')
  .description('Initialize hermit configuration')
  .option('-r, --relay-url <url>', 'Relay WebSocket URL')
  .option('-n, --machine-name <name>', 'Name for this machine')
  .option('-t, --token <token>', 'Machine token from relay')
  .option('-f, --force', 'Overwrite existing configuration')
  .action(initCommand);

program
  .command('connect')
  .description('Connect to the relay server')
  .option('-d, --daemon', 'Run in background')
  .action(connectCommand);

program
  .command('list')
  .description('List tmux sessions')
  .action(() => {
    console.log('hermit list - not yet implemented');
  });

program
  .command('new <name>')
  .description('Create a new tmux session')
  .action((name: string) => {
    console.log(`hermit new ${name} - not yet implemented`);
  });

program.parse();
```

**Step 4: Build and test manually**

Run:

```bash
pnpm --filter @hermit/agent build
pnpm --filter @hermit/agent dev -- connect --help
```

Expected: Shows connect command options

**Step 5: Commit**

```bash
git add apps/agent/src/commands apps/agent/src/cli.ts
git commit -m "M1/E1.4/1.4.6: Implement hermit connect command"
```

---

## Task 26: Implement `hermit list` Command (E1.4/1.4.7)

**Files:**

- Create: `apps/agent/src/commands/list.ts`
- Modify: `apps/agent/src/commands/index.ts`
- Modify: `apps/agent/src/cli.ts`

**Step 1: Create apps/agent/src/commands/list.ts**

```typescript
import { loadConfig } from '../config.js';
import { isTmuxAvailable, listSessions } from '../tmux.js';

export const listCommand = (): void => {
  if (!isTmuxAvailable()) {
    console.error('Error: tmux is not installed or not in PATH');
    process.exit(1);
  }

  const config = loadConfig();
  const sessions = listSessions();

  if (sessions.length === 0) {
    console.log('No tmux sessions found.');
    console.log('\nCreate a new session with: hermit new <name>');
    return;
  }

  console.log('Local tmux sessions:');
  console.log('');

  const maxNameLen = Math.max(...sessions.map((s) => s.name.length), 4);

  console.log(`${'NAME'.padEnd(maxNameLen)}  ID    CREATED               ATTACHED`);
  console.log('-'.repeat(maxNameLen + 40));

  for (const session of sessions) {
    const name = session.name.padEnd(maxNameLen);
    const id = session.id.padEnd(4);
    const created = session.createdAt.toLocaleString();
    const attached = session.attached ? 'yes' : 'no';

    console.log(`${name}  ${id}  ${created}  ${attached}`);
  }

  if (config) {
    console.log('');
    console.log(`Machine: ${config.machineName}`);
    console.log(`Relay: ${config.relayUrl}`);
  } else {
    console.log('');
    console.log('Tip: Run `hermit init` to connect these sessions to a relay.');
  }
};
```

**Step 2: Update apps/agent/src/commands/index.ts**

```typescript
export { connectCommand } from './connect.js';
export { initCommand } from './init.js';
export { listCommand } from './list.js';
```

**Step 3: Update apps/agent/src/cli.ts**

```typescript
#!/usr/bin/env node
import { Command } from 'commander';

import { connectCommand, initCommand, listCommand } from './commands/index.js';
import { VERSION } from './index.js';

const program = new Command();

program.name('hermit').description('Hermit agent - terminal relay client').version(VERSION);

program
  .command('init')
  .description('Initialize hermit configuration')
  .option('-r, --relay-url <url>', 'Relay WebSocket URL')
  .option('-n, --machine-name <name>', 'Name for this machine')
  .option('-t, --token <token>', 'Machine token from relay')
  .option('-f, --force', 'Overwrite existing configuration')
  .action(initCommand);

program
  .command('connect')
  .description('Connect to the relay server')
  .option('-d, --daemon', 'Run in background')
  .action(connectCommand);

program.command('list').description('List tmux sessions').action(listCommand);

program
  .command('new <name>')
  .description('Create a new tmux session')
  .action((name: string) => {
    console.log(`hermit new ${name} - not yet implemented`);
  });

program.parse();
```

**Step 4: Commit**

```bash
git add apps/agent/src/commands apps/agent/src/cli.ts
git commit -m "M1/E1.4/1.4.7: Implement hermit list command"
```

---

## Task 27: Implement `hermit new <name>` Command (E1.4/1.4.8)

**Files:**

- Create: `apps/agent/src/commands/new.ts`
- Modify: `apps/agent/src/commands/index.ts`
- Modify: `apps/agent/src/cli.ts`

**Step 1: Create apps/agent/src/commands/new.ts**

```typescript
import { execFileSync } from 'node:child_process';

import { createSession, isTmuxAvailable, sessionExists } from '../tmux.js';

type NewOptions = {
  command?: string;
  attach?: boolean;
};

export const newCommand = (name: string, options: NewOptions): void => {
  if (!isTmuxAvailable()) {
    console.error('Error: tmux is not installed or not in PATH');
    process.exit(1);
  }

  // Validate session name (tmux requirements)
  if (!/^[\w-]+$/.test(name)) {
    console.error(
      'Error: Session name can only contain alphanumeric characters, underscores, and hyphens',
    );
    process.exit(1);
  }

  if (sessionExists(name)) {
    console.error(`Error: Session "${name}" already exists`);
    console.error('Use a different name or kill the existing session first.');
    process.exit(1);
  }

  try {
    const session = createSession(name, options.command);
    console.log(`Created session: ${session.name} (id: ${session.id})`);

    if (options.attach) {
      console.log('Attaching to session...');
      // Use execFileSync to attach in the current terminal
      execFileSync('tmux', ['attach-session', '-t', name], { stdio: 'inherit' });
    } else {
      console.log('');
      console.log('To attach locally: tmux attach -t ' + name);
      console.log('To view remotely: Connect to the relay and select this session');
    }
  } catch (error) {
    console.error('Failed to create session:', error);
    process.exit(1);
  }
};
```

**Step 2: Update apps/agent/src/commands/index.ts**

```typescript
export { connectCommand } from './connect.js';
export { initCommand } from './init.js';
export { listCommand } from './list.js';
export { newCommand } from './new.js';
```

**Step 3: Update apps/agent/src/cli.ts (final version)**

```typescript
#!/usr/bin/env node
import { Command } from 'commander';

import { connectCommand, initCommand, listCommand, newCommand } from './commands/index.js';
import { VERSION } from './index.js';

const program = new Command();

program.name('hermit').description('Hermit agent - terminal relay client').version(VERSION);

program
  .command('init')
  .description('Initialize hermit configuration')
  .option('-r, --relay-url <url>', 'Relay WebSocket URL')
  .option('-n, --machine-name <name>', 'Name for this machine')
  .option('-t, --token <token>', 'Machine token from relay')
  .option('-f, --force', 'Overwrite existing configuration')
  .action(initCommand);

program
  .command('connect')
  .description('Connect to the relay server')
  .option('-d, --daemon', 'Run in background')
  .action(connectCommand);

program.command('list').alias('ls').description('List tmux sessions').action(listCommand);

program
  .command('new <name>')
  .description('Create a new tmux session')
  .option('-c, --command <cmd>', 'Command to run in session')
  .option('-a, --attach', 'Attach to session after creating')
  .action(newCommand);

program.parse();
```

**Step 4: Build and verify all commands**

Run:

```bash
pnpm --filter @hermit/agent build
pnpm --filter @hermit/agent dev -- --help
```

Expected: Shows all commands (init, connect, list, new)

**Step 5: Run all agent tests**

Run:

```bash
pnpm --filter @hermit/agent test
```

Expected: All tests pass

**Step 6: Commit**

```bash
git add apps/agent/src/commands apps/agent/src/cli.ts
git commit -m "M1/E1.4/1.4.8: Implement hermit new <name> command"
```

---

## Checkpoint: E1.4 Complete

At this point:

- @hermit/agent package is complete with:
  - CLI skeleton with commander.js
  - Config manager (~/.hermit/config.json)
  - Tmux controller (list/create sessions)
  - WebSocket connection to relay with reconnection
  - All CLI commands: init, connect, list, new

Run full check:

```bash
pnpm check
```

All should pass. Update roadmap and documentation before continuing to E1.5 (Web Foundation).
