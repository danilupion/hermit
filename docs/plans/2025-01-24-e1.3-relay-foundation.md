# E1.3 Relay Foundation - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create the @hermit/relay package with Hono server, PostgreSQL database, authentication, and WebSocket endpoints for agents and clients.

**Architecture:** Hono server running on Node.js with @hono/node-ws for WebSocket support. PostgreSQL for user/machine persistence. JWT for client auth, machine tokens for agent auth. In-memory registries for connected agents and clients.

**Tech Stack:**

- Hono 4.11.5, @hono/node-server 1.19.9, @hono/node-ws 1.3.0
- pg 8.17.2 (PostgreSQL client)
- jose 6.1.3 (JWT), argon2 0.44.0 (password hashing)
- Vitest 4.0.17, MSW 2.12.7 (testing)
- @hermit/protocol (shared types)

**Reference repos:**

- Monorepo patterns: `/Volumes/External Storage/Workspace/gifcept`
- Shared configs: `/Volumes/External Storage/Workspace/slango`

---

## Task 10: Create @hermit/relay Package Skeleton (E1.3/1.3.1)

**Files:**

- Create: `apps/relay/package.json`
- Create: `apps/relay/tsconfig.json`
- Create: `apps/relay/tsconfig.build.json`
- Create: `apps/relay/eslint.config.js`
- Create: `apps/relay/vitest.config.js`
- Create: `apps/relay/src/index.ts`

**Step 1: Create apps/relay/package.json**

```json
{
  "name": "@hermit/relay",
  "version": "0.0.1",
  "private": true,
  "description": "Hermit relay server",
  "type": "module",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "build": "tsc -p tsconfig.build.json",
    "build:watch": "tsc --watch -p tsconfig.build.json",
    "build:check": "tsc --noEmit",
    "start": "node dist/index.js",
    "lint": "eslint . --max-warnings 0",
    "lint:fix": "eslint . --fix --max-warnings 0",
    "test": "vitest --run",
    "test:watch": "vitest",
    "check": "pnpm build:check && pnpm lint && pnpm test"
  },
  "dependencies": {
    "@hermit/protocol": "workspace:*",
    "@hono/node-server": "1.19.9",
    "@hono/node-ws": "1.3.0",
    "argon2": "0.44.0",
    "hono": "4.11.5",
    "jose": "6.1.3",
    "pg": "8.17.2"
  },
  "devDependencies": {
    "@slango.configs/eslint": "1.1.45",
    "@slango.configs/typescript": "1.0.7",
    "@slango.configs/vitest": "2.0.2",
    "@types/node": "24.0.10",
    "@types/pg": "8.15.4",
    "@vitest/coverage-v8": "4.0.17",
    "eslint": "9.39.2",
    "msw": "2.12.7",
    "tsx": "4.20.3",
    "typescript": "5.9.3",
    "vitest": "4.0.17"
  }
}
```

**Step 2: Create apps/relay/tsconfig.json**

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@slango.configs/typescript/default.json",
  "compilerOptions": {
    "noEmit": true
  },
  "include": ["**/*.ts"],
  "exclude": ["node_modules", "dist"]
}
```

**Step 3: Create apps/relay/tsconfig.build.json**

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "noEmit": false,
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "exclude": ["node_modules", "dist", "src/**/*.test.ts"]
}
```

**Step 4: Create apps/relay/eslint.config.js**

```javascript
export { default } from '@slango.configs/eslint/typescript.js';
```

**Step 5: Create apps/relay/vitest.config.js**

```javascript
export { default } from '@slango.configs/vitest/default';
```

**Step 6: Create apps/relay/src/index.ts**

```typescript
import { serve } from '@hono/node-server';
import { Hono } from 'hono';

const app = new Hono();

app.get('/health', (c) => c.json({ status: 'ok' }));

const port = Number(process.env.PORT) || 3001;

console.log(`Relay server starting on port ${port}`);

serve({ fetch: app.fetch, port });

export { app };
```

**Step 7: Install dependencies and build**

Run:

```bash
pnpm install
pnpm --filter @hermit/relay build
```

Expected: Build succeeds, dist/ created with index.js and index.d.ts

**Step 8: Test the server starts**

Run:

```bash
pnpm --filter @hermit/relay dev &
sleep 2
curl http://localhost:3001/health
pkill -f "tsx watch"
```

Expected: `{"status":"ok"}`

**Step 9: Commit**

```bash
git add apps/relay
git commit -m "M1/E1.3/1.3.1: Create @hermit/relay package skeleton"
```

---

## Task 11: Add Health Endpoint Test (E1.3/1.3.2)

**Files:**

- Create: `apps/relay/src/index.test.ts`

**Step 1: Write the test**

Create `apps/relay/src/index.test.ts`:

```typescript
import { describe, expect, it } from 'vitest';

import { app } from './index.js';

describe('Health endpoint', () => {
  it('returns ok status', async () => {
    const res = await app.request('/health');
    expect(res.status).toBe(200);

    const body = await res.json();
    expect(body).toEqual({ status: 'ok' });
  });
});
```

**Step 2: Run tests**

Run:

```bash
pnpm --filter @hermit/relay test
```

Expected: 1 test passes

**Step 3: Commit**

```bash
git add apps/relay/src/index.test.ts
git commit -m "M1/E1.3/1.3.2: Add health endpoint test"
```

---

## Task 12: Set Up Database Module (E1.3/1.3.3)

**Files:**

- Create: `apps/relay/src/db/pool.ts`
- Create: `apps/relay/src/db/index.ts`
- Create: `apps/relay/src/db/migrations/001-initial.sql`
- Create: `apps/relay/src/db/migrate.ts`

**Step 1: Create apps/relay/src/db/pool.ts**

```typescript
import pg from 'pg';

const { Pool } = pg;

export const pool = new Pool({
  connectionString: process.env.DATABASE_URL || 'postgresql://hermit:hermit@localhost:5432/hermit',
});

export const query = <T extends pg.QueryResultRow>(
  text: string,
  params?: unknown[],
): Promise<pg.QueryResult<T>> => pool.query<T>(text, params);
```

**Step 2: Create apps/relay/src/db/migrations/001-initial.sql**

```sql
-- Users table
CREATE TABLE IF NOT EXISTS users (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email         TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  created_at    TIMESTAMPTZ DEFAULT now(),
  updated_at    TIMESTAMPTZ DEFAULT now()
);

-- Machines registered by users
CREATE TABLE IF NOT EXISTS machines (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id       UUID REFERENCES users(id) ON DELETE CASCADE,
  name          TEXT NOT NULL,
  token_hash    TEXT NOT NULL,
  last_seen     TIMESTAMPTZ,
  created_at    TIMESTAMPTZ DEFAULT now(),

  UNIQUE(user_id, name)
);

-- Refresh tokens for JWT rotation
CREATE TABLE IF NOT EXISTS refresh_tokens (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id       UUID REFERENCES users(id) ON DELETE CASCADE,
  token_hash    TEXT NOT NULL,
  expires_at    TIMESTAMPTZ NOT NULL,
  created_at    TIMESTAMPTZ DEFAULT now()
);

-- Migrations tracking
CREATE TABLE IF NOT EXISTS migrations (
  id            SERIAL PRIMARY KEY,
  name          TEXT UNIQUE NOT NULL,
  applied_at    TIMESTAMPTZ DEFAULT now()
);
```

**Step 3: Create apps/relay/src/db/migrate.ts**

```typescript
import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { pool, query } from './pool.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

export const runMigrations = async (): Promise<void> => {
  const migrationsDir = path.join(__dirname, 'migrations');
  const files = await fs.readdir(migrationsDir);
  const sqlFiles = files.filter((f) => f.endsWith('.sql')).sort();

  for (const file of sqlFiles) {
    const name = path.basename(file, '.sql');

    const { rows } = await query<{ name: string }>('SELECT name FROM migrations WHERE name = $1', [
      name,
    ]);

    if (rows.length > 0) {
      console.log(`Migration ${name} already applied, skipping`);
      continue;
    }

    const sql = await fs.readFile(path.join(migrationsDir, file), 'utf-8');
    await query(sql);
    await query('INSERT INTO migrations (name) VALUES ($1)', [name]);
    console.log(`Applied migration: ${name}`);
  }
};

export const closePool = (): Promise<void> => pool.end();
```

**Step 4: Create apps/relay/src/db/index.ts**

```typescript
export { closePool, runMigrations } from './migrate.js';
export { pool, query } from './pool.js';
```

**Step 5: Update apps/relay/src/index.ts to run migrations on startup**

```typescript
import { serve } from '@hono/node-server';
import { Hono } from 'hono';

import { runMigrations } from './db/index.js';

const app = new Hono();

app.get('/health', (c) => c.json({ status: 'ok' }));

const port = Number(process.env.PORT) || 3001;

const start = async (): Promise<void> => {
  await runMigrations();
  console.log(`Relay server starting on port ${port}`);
  serve({ fetch: app.fetch, port });
};

start().catch(console.error);

export { app };
```

**Step 6: Build and verify**

Run:

```bash
pnpm --filter @hermit/relay build
```

Expected: Build succeeds

**Step 7: Test migrations with docker postgres**

Run:

```bash
docker compose -f docker/docker-compose.yml up -d
sleep 3
pnpm --filter @hermit/relay dev &
sleep 3
pkill -f "tsx watch"
docker compose -f docker/docker-compose.yml exec postgres psql -U hermit -c "\dt"
```

Expected: Tables users, machines, refresh_tokens, migrations listed

**Step 8: Commit**

```bash
git add apps/relay/src
git commit -m "M1/E1.3/1.3.3: Add PostgreSQL connection with migrations"
```

---

## Task 13: Implement Auth Service (E1.3/1.3.4)

**Files:**

- Create: `apps/relay/src/services/auth.ts`
- Create: `apps/relay/src/services/auth.test.ts`

**Step 1: Write the failing test**

Create `apps/relay/src/services/auth.test.ts`:

```typescript
import { describe, expect, it } from 'vitest';

import { hashPassword, verifyPassword } from './auth.js';

describe('Auth service', () => {
  describe('hashPassword', () => {
    it('returns a hash different from the password', async () => {
      const password = 'mysecretpassword';
      const hash = await hashPassword(password);

      expect(hash).not.toBe(password);
      expect(hash.length).toBeGreaterThan(0);
    });
  });

  describe('verifyPassword', () => {
    it('returns true for correct password', async () => {
      const password = 'mysecretpassword';
      const hash = await hashPassword(password);

      const result = await verifyPassword(password, hash);
      expect(result).toBe(true);
    });

    it('returns false for incorrect password', async () => {
      const password = 'mysecretpassword';
      const hash = await hashPassword(password);

      const result = await verifyPassword('wrongpassword', hash);
      expect(result).toBe(false);
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run:

```bash
pnpm --filter @hermit/relay test src/services/auth.test.ts
```

Expected: FAIL with module not found

**Step 3: Create apps/relay/src/services/auth.ts**

```typescript
import * as argon2 from 'argon2';
import * as jose from 'jose';

const JWT_SECRET = new TextEncoder().encode(
  process.env.JWT_SECRET || 'hermit-dev-secret-change-in-production',
);
const JWT_ISSUER = 'hermit-relay';
const JWT_AUDIENCE = 'hermit-client';
const ACCESS_TOKEN_EXPIRY = '15m';
const REFRESH_TOKEN_EXPIRY = '7d';

export const hashPassword = async (password: string): Promise<string> => {
  return argon2.hash(password);
};

export const verifyPassword = async (password: string, hash: string): Promise<boolean> => {
  return argon2.verify(hash, password);
};

export const generateAccessToken = async (userId: string, email: string): Promise<string> => {
  return new jose.SignJWT({ sub: userId, email })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setIssuer(JWT_ISSUER)
    .setAudience(JWT_AUDIENCE)
    .setExpirationTime(ACCESS_TOKEN_EXPIRY)
    .sign(JWT_SECRET);
};

export const generateRefreshToken = async (userId: string): Promise<string> => {
  return new jose.SignJWT({ sub: userId, type: 'refresh' })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setIssuer(JWT_ISSUER)
    .setAudience(JWT_AUDIENCE)
    .setExpirationTime(REFRESH_TOKEN_EXPIRY)
    .sign(JWT_SECRET);
};

export type TokenPayload = {
  sub: string;
  email?: string;
  type?: string;
};

export const verifyToken = async (token: string): Promise<TokenPayload> => {
  const { payload } = await jose.jwtVerify(token, JWT_SECRET, {
    issuer: JWT_ISSUER,
    audience: JWT_AUDIENCE,
  });
  return payload as TokenPayload;
};

export const generateMachineToken = (): string => {
  const bytes = crypto.getRandomValues(new Uint8Array(32));
  const token = Buffer.from(bytes).toString('base64url');
  return `hmt_${token}`;
};

export const hashMachineToken = async (token: string): Promise<string> => {
  return argon2.hash(token);
};

export const verifyMachineToken = async (token: string, hash: string): Promise<boolean> => {
  return argon2.verify(hash, token);
};
```

**Step 4: Run tests to verify they pass**

Run:

```bash
pnpm --filter @hermit/relay test src/services/auth.test.ts
```

Expected: All tests pass

**Step 5: Add JWT tests**

Append to `apps/relay/src/services/auth.test.ts`:

```typescript
import {
  generateAccessToken,
  generateMachineToken,
  generateRefreshToken,
  hashMachineToken,
  hashPassword,
  verifyMachineToken,
  verifyPassword,
  verifyToken,
} from './auth.js';

// ... existing tests ...

describe('JWT tokens', () => {
  it('generates and verifies access token', async () => {
    const userId = 'user-123';
    const email = 'test@example.com';

    const token = await generateAccessToken(userId, email);
    const payload = await verifyToken(token);

    expect(payload.sub).toBe(userId);
    expect(payload.email).toBe(email);
  });

  it('generates and verifies refresh token', async () => {
    const userId = 'user-123';

    const token = await generateRefreshToken(userId);
    const payload = await verifyToken(token);

    expect(payload.sub).toBe(userId);
    expect(payload.type).toBe('refresh');
  });

  it('rejects invalid token', async () => {
    await expect(verifyToken('invalid-token')).rejects.toThrow();
  });
});

describe('Machine tokens', () => {
  it('generates token with hmt_ prefix', () => {
    const token = generateMachineToken();
    expect(token.startsWith('hmt_')).toBe(true);
    expect(token.length).toBeGreaterThan(10);
  });

  it('hashes and verifies machine token', async () => {
    const token = generateMachineToken();
    const hash = await hashMachineToken(token);

    expect(await verifyMachineToken(token, hash)).toBe(true);
    expect(await verifyMachineToken('wrong-token', hash)).toBe(false);
  });
});
```

**Step 6: Run all auth tests**

Run:

```bash
pnpm --filter @hermit/relay test src/services/auth.test.ts
```

Expected: All tests pass

**Step 7: Commit**

```bash
git add apps/relay/src/services
git commit -m "M1/E1.3/1.3.4: Implement auth service with JWT and password hashing"
```

---

## Task 14: Implement User Repository (E1.3/1.3.5)

**Files:**

- Create: `apps/relay/src/repositories/users.ts`
- Create: `apps/relay/src/repositories/users.test.ts`
- Create: `apps/relay/src/repositories/index.ts`

**Step 1: Create apps/relay/src/repositories/users.ts**

```typescript
import type { UserId, UserInfo } from '@hermit/protocol/types.js';

import { query } from '../db/index.js';
import { hashPassword } from '../services/auth.js';

export type UserRow = {
  id: string;
  email: string;
  password_hash: string;
  created_at: Date;
  updated_at: Date;
};

export const createUser = async (email: string, password: string): Promise<UserInfo> => {
  const passwordHash = await hashPassword(password);

  const { rows } = await query<UserRow>(
    'INSERT INTO users (email, password_hash) VALUES ($1, $2) RETURNING id, email',
    [email, passwordHash],
  );

  return { id: rows[0].id, email: rows[0].email };
};

export const findUserByEmail = async (email: string): Promise<UserRow | null> => {
  const { rows } = await query<UserRow>('SELECT * FROM users WHERE email = $1', [email]);

  return rows[0] || null;
};

export const findUserById = async (id: UserId): Promise<UserInfo | null> => {
  const { rows } = await query<UserRow>('SELECT id, email FROM users WHERE id = $1', [id]);

  if (!rows[0]) return null;

  return { id: rows[0].id, email: rows[0].email };
};
```

**Step 2: Create apps/relay/src/repositories/index.ts**

```typescript
export * from './users.js';
```

**Step 3: Create apps/relay/src/repositories/users.test.ts**

Note: This is an integration test that requires a real database. We'll mock it for unit testing.

```typescript
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { createUser, findUserByEmail, findUserById } from './users.js';

// Mock the db module
vi.mock('../db/index.js', () => ({
  query: vi.fn(),
}));

// Mock the auth service
vi.mock('../services/auth.js', () => ({
  hashPassword: vi.fn().mockResolvedValue('hashed_password'),
}));

import { query } from '../db/index.js';

const mockQuery = vi.mocked(query);

describe('User repository', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('createUser', () => {
    it('inserts user and returns UserInfo', async () => {
      mockQuery.mockResolvedValueOnce({
        rows: [{ id: 'user-uuid', email: 'test@example.com' }],
        command: 'INSERT',
        rowCount: 1,
        oid: 0,
        fields: [],
      });

      const result = await createUser('test@example.com', 'password123');

      expect(result).toEqual({
        id: 'user-uuid',
        email: 'test@example.com',
      });
      expect(mockQuery).toHaveBeenCalledWith(
        'INSERT INTO users (email, password_hash) VALUES ($1, $2) RETURNING id, email',
        ['test@example.com', 'hashed_password'],
      );
    });
  });

  describe('findUserByEmail', () => {
    it('returns user when found', async () => {
      const mockUser = {
        id: 'user-uuid',
        email: 'test@example.com',
        password_hash: 'hash',
        created_at: new Date(),
        updated_at: new Date(),
      };

      mockQuery.mockResolvedValueOnce({
        rows: [mockUser],
        command: 'SELECT',
        rowCount: 1,
        oid: 0,
        fields: [],
      });

      const result = await findUserByEmail('test@example.com');
      expect(result).toEqual(mockUser);
    });

    it('returns null when not found', async () => {
      mockQuery.mockResolvedValueOnce({
        rows: [],
        command: 'SELECT',
        rowCount: 0,
        oid: 0,
        fields: [],
      });

      const result = await findUserByEmail('notfound@example.com');
      expect(result).toBeNull();
    });
  });

  describe('findUserById', () => {
    it('returns UserInfo when found', async () => {
      mockQuery.mockResolvedValueOnce({
        rows: [{ id: 'user-uuid', email: 'test@example.com' }],
        command: 'SELECT',
        rowCount: 1,
        oid: 0,
        fields: [],
      });

      const result = await findUserById('user-uuid');
      expect(result).toEqual({ id: 'user-uuid', email: 'test@example.com' });
    });

    it('returns null when not found', async () => {
      mockQuery.mockResolvedValueOnce({
        rows: [],
        command: 'SELECT',
        rowCount: 0,
        oid: 0,
        fields: [],
      });

      const result = await findUserById('unknown-id');
      expect(result).toBeNull();
    });
  });
});
```

**Step 4: Run tests**

Run:

```bash
pnpm --filter @hermit/relay test src/repositories/users.test.ts
```

Expected: All tests pass

**Step 5: Commit**

```bash
git add apps/relay/src/repositories
git commit -m "M1/E1.3/1.3.5: Implement user repository"
```

---

## Task 15: Implement Auth Routes (E1.3/1.3.6)

**Files:**

- Create: `apps/relay/src/routes/auth.ts`
- Create: `apps/relay/src/routes/auth.test.ts`
- Create: `apps/relay/src/routes/index.ts`
- Modify: `apps/relay/src/index.ts`

**Step 1: Create apps/relay/src/routes/auth.ts**

```typescript
import { zValidator } from '@hono/zod-validator';
import { Hono } from 'hono';
import { z } from 'zod';

import { createUser, findUserByEmail } from '../repositories/users.js';
import { generateAccessToken, generateRefreshToken, verifyPassword } from '../services/auth.js';

const registerSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

const loginSchema = z.object({
  email: z.string().email(),
  password: z.string(),
});

export const authRoutes = new Hono()
  .post('/register', zValidator('json', registerSchema), async (c) => {
    const { email, password } = c.req.valid('json');

    const existing = await findUserByEmail(email);
    if (existing) {
      return c.json({ error: 'Email already registered' }, 400);
    }

    const user = await createUser(email, password);
    const accessToken = await generateAccessToken(user.id, user.email);
    const refreshToken = await generateRefreshToken(user.id);

    return c.json({
      user,
      accessToken,
      refreshToken,
    });
  })
  .post('/login', zValidator('json', loginSchema), async (c) => {
    const { email, password } = c.req.valid('json');

    const user = await findUserByEmail(email);
    if (!user) {
      return c.json({ error: 'Invalid credentials' }, 401);
    }

    const valid = await verifyPassword(password, user.password_hash);
    if (!valid) {
      return c.json({ error: 'Invalid credentials' }, 401);
    }

    const accessToken = await generateAccessToken(user.id, user.email);
    const refreshToken = await generateRefreshToken(user.id);

    return c.json({
      user: { id: user.id, email: user.email },
      accessToken,
      refreshToken,
    });
  });
```

**Step 2: Add @hono/zod-validator dependency**

Update `apps/relay/package.json` dependencies:

```json
{
  "dependencies": {
    "@hermit/protocol": "workspace:*",
    "@hono/node-server": "1.19.9",
    "@hono/node-ws": "1.3.0",
    "@hono/zod-validator": "0.5.0",
    "argon2": "0.44.0",
    "hono": "4.11.5",
    "jose": "6.1.3",
    "pg": "8.17.2",
    "zod": "3.25.67"
  }
}
```

**Step 3: Create apps/relay/src/routes/index.ts**

```typescript
export { authRoutes } from './auth.js';
```

**Step 4: Update apps/relay/src/index.ts**

```typescript
import { serve } from '@hono/node-server';
import { Hono } from 'hono';

import { runMigrations } from './db/index.js';
import { authRoutes } from './routes/index.js';

const app = new Hono();

app.get('/health', (c) => c.json({ status: 'ok' }));
app.route('/auth', authRoutes);

const port = Number(process.env.PORT) || 3001;

const start = async (): Promise<void> => {
  await runMigrations();
  console.log(`Relay server starting on port ${port}`);
  serve({ fetch: app.fetch, port });
};

start().catch(console.error);

export { app };
```

**Step 5: Create apps/relay/src/routes/auth.test.ts**

```typescript
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { app } from '../index.js';

// Mock the repositories
vi.mock('../repositories/users.js', () => ({
  createUser: vi.fn(),
  findUserByEmail: vi.fn(),
}));

// Mock the auth service
vi.mock('../services/auth.js', () => ({
  generateAccessToken: vi.fn().mockResolvedValue('mock-access-token'),
  generateRefreshToken: vi.fn().mockResolvedValue('mock-refresh-token'),
  verifyPassword: vi.fn(),
}));

// Mock the db
vi.mock('../db/index.js', () => ({
  runMigrations: vi.fn().mockResolvedValue(undefined),
  query: vi.fn(),
}));

import { createUser, findUserByEmail } from '../repositories/users.js';
import { verifyPassword } from '../services/auth.js';

const mockCreateUser = vi.mocked(createUser);
const mockFindUserByEmail = vi.mocked(findUserByEmail);
const mockVerifyPassword = vi.mocked(verifyPassword);

describe('Auth routes', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('POST /auth/register', () => {
    it('creates user and returns tokens', async () => {
      mockFindUserByEmail.mockResolvedValueOnce(null);
      mockCreateUser.mockResolvedValueOnce({
        id: 'user-uuid',
        email: 'test@example.com',
      });

      const res = await app.request('/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'password123',
        }),
      });

      expect(res.status).toBe(200);
      const body = await res.json();
      expect(body.user.email).toBe('test@example.com');
      expect(body.accessToken).toBe('mock-access-token');
      expect(body.refreshToken).toBe('mock-refresh-token');
    });

    it('returns 400 for existing email', async () => {
      mockFindUserByEmail.mockResolvedValueOnce({
        id: 'existing-user',
        email: 'test@example.com',
        password_hash: 'hash',
        created_at: new Date(),
        updated_at: new Date(),
      });

      const res = await app.request('/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'password123',
        }),
      });

      expect(res.status).toBe(400);
    });

    it('returns 400 for invalid email', async () => {
      const res = await app.request('/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'not-an-email',
          password: 'password123',
        }),
      });

      expect(res.status).toBe(400);
    });

    it('returns 400 for short password', async () => {
      const res = await app.request('/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'short',
        }),
      });

      expect(res.status).toBe(400);
    });
  });

  describe('POST /auth/login', () => {
    it('returns tokens for valid credentials', async () => {
      mockFindUserByEmail.mockResolvedValueOnce({
        id: 'user-uuid',
        email: 'test@example.com',
        password_hash: 'hash',
        created_at: new Date(),
        updated_at: new Date(),
      });
      mockVerifyPassword.mockResolvedValueOnce(true);

      const res = await app.request('/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'password123',
        }),
      });

      expect(res.status).toBe(200);
      const body = await res.json();
      expect(body.accessToken).toBe('mock-access-token');
    });

    it('returns 401 for unknown user', async () => {
      mockFindUserByEmail.mockResolvedValueOnce(null);

      const res = await app.request('/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'unknown@example.com',
          password: 'password123',
        }),
      });

      expect(res.status).toBe(401);
    });

    it('returns 401 for wrong password', async () => {
      mockFindUserByEmail.mockResolvedValueOnce({
        id: 'user-uuid',
        email: 'test@example.com',
        password_hash: 'hash',
        created_at: new Date(),
        updated_at: new Date(),
      });
      mockVerifyPassword.mockResolvedValueOnce(false);

      const res = await app.request('/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'wrongpassword',
        }),
      });

      expect(res.status).toBe(401);
    });
  });
});
```

**Step 6: Install dependencies and run tests**

Run:

```bash
pnpm install
pnpm --filter @hermit/relay test
```

Expected: All tests pass

**Step 7: Commit**

```bash
git add apps/relay
git commit -m "M1/E1.3/1.3.6: Implement auth routes (register, login)"
```

---

## Task 16: Implement Machine Repository and Routes (E1.3/1.3.7)

**Files:**

- Create: `apps/relay/src/repositories/machines.ts`
- Create: `apps/relay/src/repositories/machines.test.ts`
- Create: `apps/relay/src/routes/machines.ts`
- Create: `apps/relay/src/routes/machines.test.ts`
- Create: `apps/relay/src/middleware/auth.ts`
- Modify: `apps/relay/src/repositories/index.ts`
- Modify: `apps/relay/src/routes/index.ts`
- Modify: `apps/relay/src/index.ts`

**Step 1: Create apps/relay/src/middleware/auth.ts**

```typescript
import type { Context, Next } from 'hono';

import { verifyToken } from '../services/auth.js';

export type AuthVariables = {
  userId: string;
  email: string;
};

export const authMiddleware = async (c: Context, next: Next): Promise<Response | void> => {
  const authHeader = c.req.header('Authorization');

  if (!authHeader?.startsWith('Bearer ')) {
    return c.json({ error: 'Missing or invalid authorization header' }, 401);
  }

  const token = authHeader.slice(7);

  try {
    const payload = await verifyToken(token);
    c.set('userId', payload.sub);
    c.set('email', payload.email);
    await next();
  } catch {
    return c.json({ error: 'Invalid token' }, 401);
  }
};
```

**Step 2: Create apps/relay/src/repositories/machines.ts**

```typescript
import type { MachineId, MachineInfo, UserId } from '@hermit/protocol/types.js';

import { query } from '../db/index.js';
import { hashMachineToken } from '../services/auth.js';

export type MachineRow = {
  id: string;
  user_id: string;
  name: string;
  token_hash: string;
  last_seen: Date | null;
  created_at: Date;
};

export const createMachine = async (
  userId: UserId,
  name: string,
  token: string,
): Promise<MachineInfo> => {
  const tokenHash = await hashMachineToken(token);

  const { rows } = await query<MachineRow>(
    'INSERT INTO machines (user_id, name, token_hash) VALUES ($1, $2, $3) RETURNING id, name, last_seen, created_at',
    [userId, name, tokenHash],
  );

  return {
    id: rows[0].id,
    name: rows[0].name,
    online: false,
    lastSeen: rows[0].last_seen?.toISOString() || rows[0].created_at.toISOString(),
    sessionCount: 0,
  };
};

export const findMachinesByUserId = async (userId: UserId): Promise<MachineInfo[]> => {
  const { rows } = await query<MachineRow>(
    'SELECT id, name, last_seen, created_at FROM machines WHERE user_id = $1 ORDER BY name',
    [userId],
  );

  return rows.map((row) => ({
    id: row.id,
    name: row.name,
    online: false,
    lastSeen: row.last_seen?.toISOString() || row.created_at.toISOString(),
    sessionCount: 0,
  }));
};

export const findMachineById = async (id: MachineId): Promise<MachineRow | null> => {
  const { rows } = await query<MachineRow>('SELECT * FROM machines WHERE id = $1', [id]);

  return rows[0] || null;
};

export const findMachineByUserAndName = async (
  userId: UserId,
  name: string,
): Promise<MachineRow | null> => {
  const { rows } = await query<MachineRow>(
    'SELECT * FROM machines WHERE user_id = $1 AND name = $2',
    [userId, name],
  );

  return rows[0] || null;
};

export const updateMachineLastSeen = async (id: MachineId): Promise<void> => {
  await query('UPDATE machines SET last_seen = now() WHERE id = $1', [id]);
};
```

**Step 3: Update apps/relay/src/repositories/index.ts**

```typescript
export * from './machines.js';
export * from './users.js';
```

**Step 4: Create apps/relay/src/routes/machines.ts**

```typescript
import { zValidator } from '@hono/zod-validator';
import { Hono } from 'hono';
import { z } from 'zod';

import type { AuthVariables } from '../middleware/auth.js';

import { authMiddleware } from '../middleware/auth.js';
import {
  createMachine,
  findMachineByUserAndName,
  findMachinesByUserId,
} from '../repositories/machines.js';
import { generateMachineToken } from '../services/auth.js';

const createMachineSchema = z.object({
  name: z.string().min(1).max(64),
});

export const machineRoutes = new Hono<{ Variables: AuthVariables }>()
  .use('*', authMiddleware)
  .get('/', async (c) => {
    const userId = c.get('userId');
    const machines = await findMachinesByUserId(userId);
    return c.json({ machines });
  })
  .post('/', zValidator('json', createMachineSchema), async (c) => {
    const userId = c.get('userId');
    const { name } = c.req.valid('json');

    const existing = await findMachineByUserAndName(userId, name);
    if (existing) {
      return c.json({ error: 'Machine with this name already exists' }, 400);
    }

    const token = generateMachineToken();
    const machine = await createMachine(userId, name, token);

    return c.json({
      machine,
      token,
    });
  });
```

**Step 5: Update apps/relay/src/routes/index.ts**

```typescript
export { authRoutes } from './auth.js';
export { machineRoutes } from './machines.js';
```

**Step 6: Update apps/relay/src/index.ts**

```typescript
import { serve } from '@hono/node-server';
import { Hono } from 'hono';

import { runMigrations } from './db/index.js';
import { authRoutes, machineRoutes } from './routes/index.js';

const app = new Hono();

app.get('/health', (c) => c.json({ status: 'ok' }));
app.route('/auth', authRoutes);
app.route('/api/machines', machineRoutes);

const port = Number(process.env.PORT) || 3001;

const start = async (): Promise<void> => {
  await runMigrations();
  console.log(`Relay server starting on port ${port}`);
  serve({ fetch: app.fetch, port });
};

start().catch(console.error);

export { app };
```

**Step 7: Create apps/relay/src/routes/machines.test.ts**

```typescript
import { beforeEach, describe, expect, it, vi } from 'vitest';

import { app } from '../index.js';

// Mock the repositories
vi.mock('../repositories/machines.js', () => ({
  createMachine: vi.fn(),
  findMachineByUserAndName: vi.fn(),
  findMachinesByUserId: vi.fn(),
}));

// Mock the auth service
vi.mock('../services/auth.js', () => ({
  generateMachineToken: vi.fn().mockReturnValue('hmt_test-token'),
  hashMachineToken: vi.fn().mockResolvedValue('hashed'),
  verifyToken: vi.fn().mockResolvedValue({ sub: 'user-uuid', email: 'test@example.com' }),
}));

// Mock the db
vi.mock('../db/index.js', () => ({
  runMigrations: vi.fn().mockResolvedValue(undefined),
  query: vi.fn(),
}));

import {
  createMachine,
  findMachineByUserAndName,
  findMachinesByUserId,
} from '../repositories/machines.js';

const mockCreateMachine = vi.mocked(createMachine);
const mockFindMachineByUserAndName = vi.mocked(findMachineByUserAndName);
const mockFindMachinesByUserId = vi.mocked(findMachinesByUserId);

describe('Machine routes', () => {
  const validToken = 'Bearer valid-jwt-token';

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('GET /api/machines', () => {
    it('returns machines for authenticated user', async () => {
      mockFindMachinesByUserId.mockResolvedValueOnce([
        {
          id: 'machine-1',
          name: 'workstation',
          online: false,
          lastSeen: '2025-01-24T00:00:00Z',
          sessionCount: 0,
        },
      ]);

      const res = await app.request('/api/machines', {
        headers: { Authorization: validToken },
      });

      expect(res.status).toBe(200);
      const body = await res.json();
      expect(body.machines).toHaveLength(1);
      expect(body.machines[0].name).toBe('workstation');
    });

    it('returns 401 without auth header', async () => {
      const res = await app.request('/api/machines');
      expect(res.status).toBe(401);
    });
  });

  describe('POST /api/machines', () => {
    it('creates machine and returns token', async () => {
      mockFindMachineByUserAndName.mockResolvedValueOnce(null);
      mockCreateMachine.mockResolvedValueOnce({
        id: 'machine-uuid',
        name: 'my-laptop',
        online: false,
        lastSeen: '2025-01-24T00:00:00Z',
        sessionCount: 0,
      });

      const res = await app.request('/api/machines', {
        method: 'POST',
        headers: {
          Authorization: validToken,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name: 'my-laptop' }),
      });

      expect(res.status).toBe(200);
      const body = await res.json();
      expect(body.machine.name).toBe('my-laptop');
      expect(body.token).toBe('hmt_test-token');
    });

    it('returns 400 for duplicate name', async () => {
      mockFindMachineByUserAndName.mockResolvedValueOnce({
        id: 'existing',
        user_id: 'user-uuid',
        name: 'my-laptop',
        token_hash: 'hash',
        last_seen: null,
        created_at: new Date(),
      });

      const res = await app.request('/api/machines', {
        method: 'POST',
        headers: {
          Authorization: validToken,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ name: 'my-laptop' }),
      });

      expect(res.status).toBe(400);
    });
  });
});
```

**Step 8: Create apps/relay/src/repositories/machines.test.ts**

```typescript
import { beforeEach, describe, expect, it, vi } from 'vitest';

import {
  createMachine,
  findMachineById,
  findMachineByUserAndName,
  findMachinesByUserId,
} from './machines.js';

// Mock the db module
vi.mock('../db/index.js', () => ({
  query: vi.fn(),
}));

// Mock the auth service
vi.mock('../services/auth.js', () => ({
  hashMachineToken: vi.fn().mockResolvedValue('hashed_token'),
}));

import { query } from '../db/index.js';

const mockQuery = vi.mocked(query);

describe('Machine repository', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('createMachine', () => {
    it('inserts machine and returns MachineInfo', async () => {
      const createdAt = new Date();
      mockQuery.mockResolvedValueOnce({
        rows: [
          {
            id: 'machine-uuid',
            name: 'workstation',
            last_seen: null,
            created_at: createdAt,
          },
        ],
        command: 'INSERT',
        rowCount: 1,
        oid: 0,
        fields: [],
      });

      const result = await createMachine('user-uuid', 'workstation', 'hmt_token');

      expect(result).toEqual({
        id: 'machine-uuid',
        name: 'workstation',
        online: false,
        lastSeen: createdAt.toISOString(),
        sessionCount: 0,
      });
    });
  });

  describe('findMachinesByUserId', () => {
    it('returns array of MachineInfo', async () => {
      const lastSeen = new Date();
      mockQuery.mockResolvedValueOnce({
        rows: [
          { id: 'm1', name: 'laptop', last_seen: lastSeen, created_at: new Date() },
          { id: 'm2', name: 'desktop', last_seen: null, created_at: new Date() },
        ],
        command: 'SELECT',
        rowCount: 2,
        oid: 0,
        fields: [],
      });

      const result = await findMachinesByUserId('user-uuid');

      expect(result).toHaveLength(2);
      expect(result[0].name).toBe('laptop');
      expect(result[0].lastSeen).toBe(lastSeen.toISOString());
    });
  });

  describe('findMachineById', () => {
    it('returns machine row when found', async () => {
      const mockMachine = {
        id: 'machine-uuid',
        user_id: 'user-uuid',
        name: 'workstation',
        token_hash: 'hash',
        last_seen: null,
        created_at: new Date(),
      };

      mockQuery.mockResolvedValueOnce({
        rows: [mockMachine],
        command: 'SELECT',
        rowCount: 1,
        oid: 0,
        fields: [],
      });

      const result = await findMachineById('machine-uuid');
      expect(result).toEqual(mockMachine);
    });

    it('returns null when not found', async () => {
      mockQuery.mockResolvedValueOnce({
        rows: [],
        command: 'SELECT',
        rowCount: 0,
        oid: 0,
        fields: [],
      });

      const result = await findMachineById('unknown');
      expect(result).toBeNull();
    });
  });

  describe('findMachineByUserAndName', () => {
    it('returns machine when found', async () => {
      mockQuery.mockResolvedValueOnce({
        rows: [{ id: 'machine-uuid', name: 'laptop' }],
        command: 'SELECT',
        rowCount: 1,
        oid: 0,
        fields: [],
      });

      const result = await findMachineByUserAndName('user-uuid', 'laptop');
      expect(result).toBeDefined();
    });
  });
});
```

**Step 9: Run all tests**

Run:

```bash
pnpm --filter @hermit/relay test
```

Expected: All tests pass

**Step 10: Commit**

```bash
git add apps/relay/src
git commit -m "M1/E1.3/1.3.7: Implement machine repository and routes"
```

---

## Task 17: Implement Agent Registry (E1.3/1.3.8)

**Files:**

- Create: `apps/relay/src/registries/agents.ts`
- Create: `apps/relay/src/registries/agents.test.ts`
- Create: `apps/relay/src/registries/index.ts`

**Step 1: Create apps/relay/src/registries/agents.ts**

```typescript
import type { MachineId, SessionInfo } from '@hermit/protocol/types.js';
import type { ServerWebSocket } from '@hono/node-ws';

export type AgentConnection = {
  machineId: MachineId;
  machineName: string;
  userId: string;
  ws: ServerWebSocket;
  sessions: Map<string, SessionInfo>;
  connectedAt: Date;
};

const agents = new Map<MachineId, AgentConnection>();

export const registerAgent = (
  machineId: MachineId,
  machineName: string,
  userId: string,
  ws: ServerWebSocket,
): void => {
  agents.set(machineId, {
    machineId,
    machineName,
    userId,
    ws,
    sessions: new Map(),
    connectedAt: new Date(),
  });
};

export const unregisterAgent = (machineId: MachineId): void => {
  agents.delete(machineId);
};

export const getAgent = (machineId: MachineId): AgentConnection | undefined => {
  return agents.get(machineId);
};

export const getAgentsByUserId = (userId: string): AgentConnection[] => {
  return Array.from(agents.values()).filter((agent) => agent.userId === userId);
};

export const isAgentOnline = (machineId: MachineId): boolean => {
  return agents.has(machineId);
};

export const updateAgentSessions = (machineId: MachineId, sessions: SessionInfo[]): void => {
  const agent = agents.get(machineId);
  if (agent) {
    agent.sessions.clear();
    for (const session of sessions) {
      agent.sessions.set(session.id, session);
    }
  }
};

export const getAgentSessions = (machineId: MachineId): SessionInfo[] => {
  const agent = agents.get(machineId);
  return agent ? Array.from(agent.sessions.values()) : [];
};

export const addAgentSession = (machineId: MachineId, session: SessionInfo): void => {
  const agent = agents.get(machineId);
  if (agent) {
    agent.sessions.set(session.id, session);
  }
};

export const removeAgentSession = (machineId: MachineId, sessionId: string): void => {
  const agent = agents.get(machineId);
  if (agent) {
    agent.sessions.delete(sessionId);
  }
};

export const getAllAgents = (): AgentConnection[] => {
  return Array.from(agents.values());
};

export const clearAgents = (): void => {
  agents.clear();
};
```

**Step 2: Create apps/relay/src/registries/index.ts**

```typescript
export * from './agents.js';
```

**Step 3: Create apps/relay/src/registries/agents.test.ts**

```typescript
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

import {
  addAgentSession,
  clearAgents,
  getAgent,
  getAgentsByUserId,
  getAgentSessions,
  isAgentOnline,
  registerAgent,
  removeAgentSession,
  unregisterAgent,
  updateAgentSessions,
} from './agents.js';

describe('Agent registry', () => {
  const mockWs = { send: vi.fn(), close: vi.fn() } as unknown as Parameters<
    typeof registerAgent
  >[3];

  beforeEach(() => {
    clearAgents();
  });

  afterEach(() => {
    clearAgents();
  });

  describe('registerAgent', () => {
    it('registers an agent', () => {
      registerAgent('machine-1', 'Workstation', 'user-1', mockWs);

      const agent = getAgent('machine-1');
      expect(agent).toBeDefined();
      expect(agent?.machineName).toBe('Workstation');
      expect(agent?.userId).toBe('user-1');
    });
  });

  describe('unregisterAgent', () => {
    it('removes an agent', () => {
      registerAgent('machine-1', 'Workstation', 'user-1', mockWs);
      unregisterAgent('machine-1');

      expect(getAgent('machine-1')).toBeUndefined();
    });
  });

  describe('isAgentOnline', () => {
    it('returns true for registered agent', () => {
      registerAgent('machine-1', 'Workstation', 'user-1', mockWs);
      expect(isAgentOnline('machine-1')).toBe(true);
    });

    it('returns false for unknown agent', () => {
      expect(isAgentOnline('unknown')).toBe(false);
    });
  });

  describe('getAgentsByUserId', () => {
    it('returns agents for a user', () => {
      registerAgent('machine-1', 'Laptop', 'user-1', mockWs);
      registerAgent('machine-2', 'Desktop', 'user-1', mockWs);
      registerAgent('machine-3', 'Other', 'user-2', mockWs);

      const agents = getAgentsByUserId('user-1');
      expect(agents).toHaveLength(2);
    });
  });

  describe('session management', () => {
    it('updates and retrieves sessions', () => {
      registerAgent('machine-1', 'Workstation', 'user-1', mockWs);

      updateAgentSessions('machine-1', [
        {
          id: 'session-1',
          name: 'claude',
          command: 'claude',
          createdAt: '2025-01-24T00:00:00Z',
          attachedClients: 0,
        },
      ]);

      const sessions = getAgentSessions('machine-1');
      expect(sessions).toHaveLength(1);
      expect(sessions[0].name).toBe('claude');
    });

    it('adds a session', () => {
      registerAgent('machine-1', 'Workstation', 'user-1', mockWs);

      addAgentSession('machine-1', {
        id: 'session-1',
        name: 'bash',
        command: 'bash',
        createdAt: '2025-01-24T00:00:00Z',
        attachedClients: 0,
      });

      expect(getAgentSessions('machine-1')).toHaveLength(1);
    });

    it('removes a session', () => {
      registerAgent('machine-1', 'Workstation', 'user-1', mockWs);
      addAgentSession('machine-1', {
        id: 'session-1',
        name: 'bash',
        command: 'bash',
        createdAt: '2025-01-24T00:00:00Z',
        attachedClients: 0,
      });

      removeAgentSession('machine-1', 'session-1');
      expect(getAgentSessions('machine-1')).toHaveLength(0);
    });
  });
});
```

**Step 4: Run tests**

Run:

```bash
pnpm --filter @hermit/relay test src/registries/agents.test.ts
```

Expected: All tests pass

**Step 5: Commit**

```bash
git add apps/relay/src/registries
git commit -m "M1/E1.3/1.3.8: Implement agent registry (in-memory)"
```

---

## Task 18: Implement Client Registry (E1.3/1.3.9)

**Files:**

- Create: `apps/relay/src/registries/clients.ts`
- Create: `apps/relay/src/registries/clients.test.ts`
- Modify: `apps/relay/src/registries/index.ts`

**Step 1: Create apps/relay/src/registries/clients.ts**

```typescript
import type { ClientId, MachineId, SessionId, UserId } from '@hermit/protocol/types.js';
import type { ServerWebSocket } from '@hono/node-ws';

export type ClientConnection = {
  clientId: ClientId;
  userId: UserId;
  ws: ServerWebSocket;
  attachedSessions: Map<SessionId, MachineId>;
  connectedAt: Date;
};

const clients = new Map<ClientId, ClientConnection>();

export const registerClient = (clientId: ClientId, userId: UserId, ws: ServerWebSocket): void => {
  clients.set(clientId, {
    clientId,
    userId,
    ws,
    attachedSessions: new Map(),
    connectedAt: new Date(),
  });
};

export const unregisterClient = (clientId: ClientId): void => {
  clients.delete(clientId);
};

export const getClient = (clientId: ClientId): ClientConnection | undefined => {
  return clients.get(clientId);
};

export const getClientsByUserId = (userId: UserId): ClientConnection[] => {
  return Array.from(clients.values()).filter((client) => client.userId === userId);
};

export const attachClientToSession = (
  clientId: ClientId,
  sessionId: SessionId,
  machineId: MachineId,
): void => {
  const client = clients.get(clientId);
  if (client) {
    client.attachedSessions.set(sessionId, machineId);
  }
};

export const detachClientFromSession = (clientId: ClientId, sessionId: SessionId): void => {
  const client = clients.get(clientId);
  if (client) {
    client.attachedSessions.delete(sessionId);
  }
};

export const getClientsAttachedToSession = (
  machineId: MachineId,
  sessionId: SessionId,
): ClientConnection[] => {
  return Array.from(clients.values()).filter((client) => {
    const attachedMachine = client.attachedSessions.get(sessionId);
    return attachedMachine === machineId;
  });
};

export const clearClients = (): void => {
  clients.clear();
};
```

**Step 2: Update apps/relay/src/registries/index.ts**

```typescript
export * from './agents.js';
export * from './clients.js';
```

**Step 3: Create apps/relay/src/registries/clients.test.ts**

```typescript
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';

import {
  attachClientToSession,
  clearClients,
  detachClientFromSession,
  getClient,
  getClientsAttachedToSession,
  getClientsByUserId,
  registerClient,
  unregisterClient,
} from './clients.js';

describe('Client registry', () => {
  const mockWs = { send: vi.fn(), close: vi.fn() } as unknown as Parameters<
    typeof registerClient
  >[2];

  beforeEach(() => {
    clearClients();
  });

  afterEach(() => {
    clearClients();
  });

  describe('registerClient', () => {
    it('registers a client', () => {
      registerClient('client-1', 'user-1', mockWs);

      const client = getClient('client-1');
      expect(client).toBeDefined();
      expect(client?.userId).toBe('user-1');
    });
  });

  describe('unregisterClient', () => {
    it('removes a client', () => {
      registerClient('client-1', 'user-1', mockWs);
      unregisterClient('client-1');

      expect(getClient('client-1')).toBeUndefined();
    });
  });

  describe('getClientsByUserId', () => {
    it('returns clients for a user', () => {
      registerClient('client-1', 'user-1', mockWs);
      registerClient('client-2', 'user-1', mockWs);
      registerClient('client-3', 'user-2', mockWs);

      const clients = getClientsByUserId('user-1');
      expect(clients).toHaveLength(2);
    });
  });

  describe('session attachment', () => {
    it('attaches client to session', () => {
      registerClient('client-1', 'user-1', mockWs);
      attachClientToSession('client-1', 'session-1', 'machine-1');

      const client = getClient('client-1');
      expect(client?.attachedSessions.get('session-1')).toBe('machine-1');
    });

    it('detaches client from session', () => {
      registerClient('client-1', 'user-1', mockWs);
      attachClientToSession('client-1', 'session-1', 'machine-1');
      detachClientFromSession('client-1', 'session-1');

      const client = getClient('client-1');
      expect(client?.attachedSessions.has('session-1')).toBe(false);
    });

    it('finds clients attached to a session', () => {
      registerClient('client-1', 'user-1', mockWs);
      registerClient('client-2', 'user-1', mockWs);
      registerClient('client-3', 'user-1', mockWs);

      attachClientToSession('client-1', 'session-1', 'machine-1');
      attachClientToSession('client-2', 'session-1', 'machine-1');
      attachClientToSession('client-3', 'session-2', 'machine-1');

      const attached = getClientsAttachedToSession('machine-1', 'session-1');
      expect(attached).toHaveLength(2);
    });
  });
});
```

**Step 4: Run tests**

Run:

```bash
pnpm --filter @hermit/relay test src/registries/clients.test.ts
```

Expected: All tests pass

**Step 5: Commit**

```bash
git add apps/relay/src/registries
git commit -m "M1/E1.3/1.3.9: Implement client registry (in-memory)"
```

---

## Task 19: Implement WebSocket Endpoints (E1.3/1.3.10)

**Files:**

- Create: `apps/relay/src/ws/agent-handler.ts`
- Create: `apps/relay/src/ws/client-handler.ts`
- Create: `apps/relay/src/ws/index.ts`
- Modify: `apps/relay/src/index.ts`

**Step 1: Create apps/relay/src/ws/agent-handler.ts**

```typescript
import type { AgentMessage } from '@hermit/protocol/agent-messages.js';
import type { ServerWebSocket, WSContext } from '@hono/node-ws';

import { safeParseAgentMessage } from '@hermit/protocol/schemas.js';

import { findMachineById, updateMachineLastSeen } from '../repositories/machines.js';
import {
  addAgentSession,
  getAgent,
  registerAgent,
  removeAgentSession,
  unregisterAgent,
  updateAgentSessions,
} from '../registries/agents.js';
import { getClientsAttachedToSession } from '../registries/clients.js';
import { verifyMachineToken } from '../services/auth.js';

type AgentState = {
  machineId: string | null;
  authenticated: boolean;
};

const sendToAgent = (ws: ServerWebSocket, message: object): void => {
  ws.send(JSON.stringify(message));
};

const broadcastToClients = (machineId: string, sessionId: string, message: object): void => {
  const clients = getClientsAttachedToSession(machineId, sessionId);
  const json = JSON.stringify(message);
  for (const client of clients) {
    client.ws.send(json);
  }
};

export const handleAgentConnection = (ws: WSContext): void => {
  const state: AgentState = {
    machineId: null,
    authenticated: false,
  };

  ws.onmessage = async (event: MessageEvent): Promise<void> => {
    const data = typeof event.data === 'string' ? event.data : event.data.toString();
    let parsed: unknown;

    try {
      parsed = JSON.parse(data);
    } catch {
      sendToAgent(ws as unknown as ServerWebSocket, {
        type: 'error',
        code: 'INVALID_JSON',
        message: 'Invalid JSON',
      });
      return;
    }

    const result = safeParseAgentMessage(parsed);
    if (!result.success) {
      sendToAgent(ws as unknown as ServerWebSocket, {
        type: 'error',
        code: 'INVALID_MESSAGE',
        message: 'Invalid message format',
      });
      return;
    }

    const message = result.data as AgentMessage;
    await handleAgentMessage(ws as unknown as ServerWebSocket, state, message);
  };

  ws.onclose = (): void => {
    if (state.machineId) {
      unregisterAgent(state.machineId);
      console.log(`Agent disconnected: ${state.machineId}`);
    }
  };

  ws.onerror = (error: Event): void => {
    console.error('Agent WebSocket error:', error);
  };
};

const handleAgentMessage = async (
  ws: ServerWebSocket,
  state: AgentState,
  message: AgentMessage,
): Promise<void> => {
  if (message.type === 'register') {
    const machine = await findMachineById(message.machineName);
    if (!machine) {
      sendToAgent(ws, { type: 'registered', success: false, error: 'Machine not found' });
      return;
    }

    const valid = await verifyMachineToken(message.token, machine.token_hash);
    if (!valid) {
      sendToAgent(ws, { type: 'registered', success: false, error: 'Invalid token' });
      return;
    }

    state.machineId = machine.id;
    state.authenticated = true;

    registerAgent(machine.id, machine.name, machine.user_id, ws);
    await updateMachineLastSeen(machine.id);

    sendToAgent(ws, { type: 'registered', success: true, machineId: machine.id });
    sendToAgent(ws, { type: 'list_sessions' });

    console.log(`Agent registered: ${machine.name} (${machine.id})`);
    return;
  }

  if (!state.authenticated || !state.machineId) {
    sendToAgent(ws, { type: 'error', code: 'NOT_AUTHENTICATED', message: 'Not authenticated' });
    return;
  }

  switch (message.type) {
    case 'sessions':
      updateAgentSessions(state.machineId, message.sessions);
      break;

    case 'session_started':
      addAgentSession(state.machineId, message.session);
      break;

    case 'session_ended':
      removeAgentSession(state.machineId, message.sessionId);
      break;

    case 'data':
      broadcastToClients(state.machineId, message.sessionId, {
        type: 'data',
        sessionId: message.sessionId,
        data: message.data,
      });
      break;

    case 'pong':
      break;
  }
};

export const sendToAgentByMachineId = (machineId: string, message: object): boolean => {
  const agent = getAgent(machineId);
  if (!agent) return false;
  agent.ws.send(JSON.stringify(message));
  return true;
};
```

**Step 2: Create apps/relay/src/ws/client-handler.ts**

```typescript
import type { ClientMessage } from '@hermit/protocol/client-messages.js';
import type { ServerWebSocket, WSContext } from '@hono/node-ws';

import { safeParseClientMessage } from '@hermit/protocol/schemas.js';

import { findMachinesByUserId } from '../repositories/machines.js';
import { findUserById } from '../repositories/users.js';
import {
  getAgent,
  getAgentsByUserId,
  getAgentSessions,
  isAgentOnline,
} from '../registries/agents.js';
import {
  attachClientToSession,
  detachClientFromSession,
  registerClient,
  unregisterClient,
} from '../registries/clients.js';
import { verifyToken } from '../services/auth.js';
import { sendToAgentByMachineId } from './agent-handler.js';

type ClientState = {
  clientId: string;
  userId: string | null;
  authenticated: boolean;
};

const sendToClient = (ws: ServerWebSocket, message: object): void => {
  ws.send(JSON.stringify(message));
};

export const handleClientConnection = (ws: WSContext): void => {
  const clientId = crypto.randomUUID();
  const state: ClientState = {
    clientId,
    userId: null,
    authenticated: false,
  };

  ws.onmessage = async (event: MessageEvent): Promise<void> => {
    const data = typeof event.data === 'string' ? event.data : event.data.toString();
    let parsed: unknown;

    try {
      parsed = JSON.parse(data);
    } catch {
      sendToClient(ws as unknown as ServerWebSocket, {
        type: 'error',
        code: 'INVALID_JSON',
        message: 'Invalid JSON',
      });
      return;
    }

    const result = safeParseClientMessage(parsed);
    if (!result.success) {
      sendToClient(ws as unknown as ServerWebSocket, {
        type: 'error',
        code: 'INVALID_MESSAGE',
        message: 'Invalid message format',
      });
      return;
    }

    const message = result.data as ClientMessage;
    await handleClientMessage(ws as unknown as ServerWebSocket, state, message);
  };

  ws.onclose = (): void => {
    if (state.authenticated) {
      unregisterClient(state.clientId);
      console.log(`Client disconnected: ${state.clientId}`);
    }
  };

  ws.onerror = (error: Event): void => {
    console.error('Client WebSocket error:', error);
  };
};

const handleClientMessage = async (
  ws: ServerWebSocket,
  state: ClientState,
  message: ClientMessage,
): Promise<void> => {
  if (message.type === 'auth') {
    try {
      const payload = await verifyToken(message.token);
      const user = await findUserById(payload.sub);

      if (!user) {
        sendToClient(ws, { type: 'error', code: 'USER_NOT_FOUND', message: 'User not found' });
        return;
      }

      state.userId = user.id;
      state.authenticated = true;

      registerClient(state.clientId, user.id, ws);

      sendToClient(ws, { type: 'authenticated', user });
      console.log(`Client authenticated: ${state.clientId} (${user.email})`);
    } catch {
      sendToClient(ws, { type: 'error', code: 'INVALID_TOKEN', message: 'Invalid token' });
    }
    return;
  }

  if (!state.authenticated || !state.userId) {
    sendToClient(ws, { type: 'error', code: 'NOT_AUTHENTICATED', message: 'Not authenticated' });
    return;
  }

  switch (message.type) {
    case 'list_machines': {
      const dbMachines = await findMachinesByUserId(state.userId);
      const onlineAgents = getAgentsByUserId(state.userId);
      const onlineIds = new Set(onlineAgents.map((a) => a.machineId));

      const machines = dbMachines.map((m) => ({
        ...m,
        online: onlineIds.has(m.id),
        sessionCount: isAgentOnline(m.id) ? getAgentSessions(m.id).length : 0,
      }));

      sendToClient(ws, { type: 'machines', machines });
      break;
    }

    case 'list_sessions': {
      const sessions = getAgentSessions(message.machineId);
      sendToClient(ws, {
        type: 'sessions',
        machineId: message.machineId,
        sessions,
      });
      break;
    }

    case 'attach': {
      const agent = getAgent(message.machineId);
      if (!agent || agent.userId !== state.userId) {
        sendToClient(ws, {
          type: 'error',
          code: 'MACHINE_NOT_FOUND',
          message: 'Machine not found or offline',
        });
        return;
      }

      attachClientToSession(state.clientId, message.sessionId, message.machineId);
      sendToAgentByMachineId(message.machineId, {
        type: 'attach',
        sessionId: message.sessionId,
        clientId: state.clientId,
      });
      sendToClient(ws, { type: 'attached', sessionId: message.sessionId });
      break;
    }

    case 'detach': {
      detachClientFromSession(state.clientId, message.sessionId);
      sendToClient(ws, { type: 'detached', sessionId: message.sessionId });
      break;
    }

    case 'create_session': {
      const agent = getAgent(message.machineId);
      if (!agent || agent.userId !== state.userId) {
        sendToClient(ws, {
          type: 'error',
          code: 'MACHINE_NOT_FOUND',
          message: 'Machine not found or offline',
        });
        return;
      }

      sendToAgentByMachineId(message.machineId, {
        type: 'start_session',
        name: message.name,
        command: message.command,
      });
      break;
    }

    case 'data': {
      // Find which machine this session is on
      // For now, we'll need to iterate through attached sessions
      // This could be optimized with a reverse lookup
      const client = await import('../registries/clients.js').then((m) =>
        m.getClient(state.clientId),
      );
      if (!client) break;

      const machineId = client.attachedSessions.get(message.sessionId);
      if (machineId) {
        sendToAgentByMachineId(machineId, {
          type: 'data',
          sessionId: message.sessionId,
          data: message.data,
        });
      }
      break;
    }

    case 'resize': {
      const client = await import('../registries/clients.js').then((m) =>
        m.getClient(state.clientId),
      );
      if (!client) break;

      const machineId = client.attachedSessions.get(message.sessionId);
      if (machineId) {
        sendToAgentByMachineId(machineId, {
          type: 'resize',
          sessionId: message.sessionId,
          cols: message.cols,
          rows: message.rows,
        });
      }
      break;
    }

    case 'pong':
      break;
  }
};
```

**Step 3: Create apps/relay/src/ws/index.ts**

```typescript
export { handleAgentConnection, sendToAgentByMachineId } from './agent-handler.js';
export { handleClientConnection } from './client-handler.js';
```

**Step 4: Update apps/relay/src/index.ts to add WebSocket endpoints**

```typescript
import { createNodeWebSocket } from '@hono/node-ws';
import { serve } from '@hono/node-server';
import { Hono } from 'hono';

import { runMigrations } from './db/index.js';
import { authRoutes, machineRoutes } from './routes/index.js';
import { handleAgentConnection, handleClientConnection } from './ws/index.js';

const app = new Hono();
const { injectWebSocket, upgradeWebSocket } = createNodeWebSocket({ app });

app.get('/health', (c) => c.json({ status: 'ok' }));
app.route('/auth', authRoutes);
app.route('/api/machines', machineRoutes);

app.get(
  '/ws/agent',
  upgradeWebSocket(() => ({
    onOpen: (_, ws) => handleAgentConnection(ws),
  })),
);

app.get(
  '/ws/client',
  upgradeWebSocket(() => ({
    onOpen: (_, ws) => handleClientConnection(ws),
  })),
);

const port = Number(process.env.PORT) || 3001;

const start = async (): Promise<void> => {
  await runMigrations();
  console.log(`Relay server starting on port ${port}`);
  const server = serve({ fetch: app.fetch, port });
  injectWebSocket(server);
};

start().catch(console.error);

export { app };
```

**Step 5: Run build to verify compilation**

Run:

```bash
pnpm --filter @hermit/relay build
```

Expected: Build succeeds

**Step 6: Run all tests**

Run:

```bash
pnpm --filter @hermit/relay test
```

Expected: All tests pass

**Step 7: Commit**

```bash
git add apps/relay/src
git commit -m "M1/E1.3/1.3.10: Implement WebSocket endpoints for agents and clients"
```

---

## Checkpoint: E1.3 Complete

At this point:

- @hermit/relay package is complete with:
  - Hono server with health endpoint
  - PostgreSQL migrations and connection
  - Auth service (JWT, password hashing, machine tokens)
  - User and machine repositories
  - Auth routes (register, login)
  - Machine routes (list, create)
  - Agent and client registries (in-memory)
  - WebSocket endpoints (/ws/agent, /ws/client)

Run full check:

```bash
pnpm check
```

All should pass. The plan continues with E1.4 (Agent) and E1.5 (Web) in subsequent tasks.
